ARM GAS  /tmp/cca6hA9x.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"stm32f4xx_pwr.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.PWR_DeInit,"ax",%progbits
  18              		.align	1
  19              		.global	PWR_DeInit
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	PWR_DeInit:
  26              	.LFB112:
  27              		.file 1 "./FWLIB/src/stm32f4xx_pwr.c"
   1:./FWLIB/src/stm32f4xx_pwr.c **** /**
   2:./FWLIB/src/stm32f4xx_pwr.c ****   ******************************************************************************
   3:./FWLIB/src/stm32f4xx_pwr.c ****   * @file    stm32f4xx_pwr.c
   4:./FWLIB/src/stm32f4xx_pwr.c ****   * @author  MCD Application Team
   5:./FWLIB/src/stm32f4xx_pwr.c ****   * @version V1.4.0
   6:./FWLIB/src/stm32f4xx_pwr.c ****   * @date    04-August-2014
   7:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief   This file provides firmware functions to manage the following 
   8:./FWLIB/src/stm32f4xx_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:           
   9:./FWLIB/src/stm32f4xx_pwr.c ****   *           + Backup Domain Access
  10:./FWLIB/src/stm32f4xx_pwr.c ****   *           + PVD configuration
  11:./FWLIB/src/stm32f4xx_pwr.c ****   *           + WakeUp pin configuration
  12:./FWLIB/src/stm32f4xx_pwr.c ****   *           + Main and Backup Regulators configuration
  13:./FWLIB/src/stm32f4xx_pwr.c ****   *           + FLASH Power Down configuration
  14:./FWLIB/src/stm32f4xx_pwr.c ****   *           + Low Power modes configuration
  15:./FWLIB/src/stm32f4xx_pwr.c ****   *           + Flags management
  16:./FWLIB/src/stm32f4xx_pwr.c ****   *               
  17:./FWLIB/src/stm32f4xx_pwr.c ****   ******************************************************************************
  18:./FWLIB/src/stm32f4xx_pwr.c ****   * @attention
  19:./FWLIB/src/stm32f4xx_pwr.c ****   *
  20:./FWLIB/src/stm32f4xx_pwr.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  21:./FWLIB/src/stm32f4xx_pwr.c ****   *
  22:./FWLIB/src/stm32f4xx_pwr.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  23:./FWLIB/src/stm32f4xx_pwr.c ****   * You may not use this file except in compliance with the License.
  24:./FWLIB/src/stm32f4xx_pwr.c ****   * You may obtain a copy of the License at:
  25:./FWLIB/src/stm32f4xx_pwr.c ****   *
  26:./FWLIB/src/stm32f4xx_pwr.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  27:./FWLIB/src/stm32f4xx_pwr.c ****   *
  28:./FWLIB/src/stm32f4xx_pwr.c ****   * Unless required by applicable law or agreed to in writing, software 
  29:./FWLIB/src/stm32f4xx_pwr.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  30:./FWLIB/src/stm32f4xx_pwr.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  31:./FWLIB/src/stm32f4xx_pwr.c ****   * See the License for the specific language governing permissions and
ARM GAS  /tmp/cca6hA9x.s 			page 2


  32:./FWLIB/src/stm32f4xx_pwr.c ****   * limitations under the License.
  33:./FWLIB/src/stm32f4xx_pwr.c ****   *
  34:./FWLIB/src/stm32f4xx_pwr.c ****   ******************************************************************************
  35:./FWLIB/src/stm32f4xx_pwr.c ****   */ 
  36:./FWLIB/src/stm32f4xx_pwr.c **** 
  37:./FWLIB/src/stm32f4xx_pwr.c **** /* Includes ------------------------------------------------------------------*/
  38:./FWLIB/src/stm32f4xx_pwr.c **** #include "stm32f4xx_pwr.h"
  39:./FWLIB/src/stm32f4xx_pwr.c **** #include "stm32f4xx_rcc.h"
  40:./FWLIB/src/stm32f4xx_pwr.c **** 
  41:./FWLIB/src/stm32f4xx_pwr.c **** /** @addtogroup STM32F4xx_StdPeriph_Driver
  42:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
  43:./FWLIB/src/stm32f4xx_pwr.c ****   */
  44:./FWLIB/src/stm32f4xx_pwr.c **** 
  45:./FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR 
  46:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief PWR driver modules
  47:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
  48:./FWLIB/src/stm32f4xx_pwr.c ****   */ 
  49:./FWLIB/src/stm32f4xx_pwr.c **** 
  50:./FWLIB/src/stm32f4xx_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  51:./FWLIB/src/stm32f4xx_pwr.c **** /* Private define ------------------------------------------------------------*/
  52:./FWLIB/src/stm32f4xx_pwr.c **** /* --------- PWR registers bit address in the alias region ---------- */
  53:./FWLIB/src/stm32f4xx_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  54:./FWLIB/src/stm32f4xx_pwr.c **** 
  55:./FWLIB/src/stm32f4xx_pwr.c **** /* --- CR Register ---*/
  56:./FWLIB/src/stm32f4xx_pwr.c **** 
  57:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of DBP bit */
  58:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_OFFSET                (PWR_OFFSET + 0x00)
  59:./FWLIB/src/stm32f4xx_pwr.c **** #define DBP_BitNumber            0x08
  60:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
  61:./FWLIB/src/stm32f4xx_pwr.c **** 
  62:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of PVDE bit */
  63:./FWLIB/src/stm32f4xx_pwr.c **** #define PVDE_BitNumber           0x04
  64:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
  65:./FWLIB/src/stm32f4xx_pwr.c **** 
  66:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of FPDS bit */
  67:./FWLIB/src/stm32f4xx_pwr.c **** #define FPDS_BitNumber           0x09
  68:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_FPDS_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (FPDS_BitNumber * 4))
  69:./FWLIB/src/stm32f4xx_pwr.c **** 
  70:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of PMODE bit */
  71:./FWLIB/src/stm32f4xx_pwr.c **** #define PMODE_BitNumber           0x0E
  72:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_PMODE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PMODE_BitNumber * 4))
  73:./FWLIB/src/stm32f4xx_pwr.c **** 
  74:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of ODEN bit */
  75:./FWLIB/src/stm32f4xx_pwr.c **** #define ODEN_BitNumber           0x10
  76:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_ODEN_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (ODEN_BitNumber * 4))
  77:./FWLIB/src/stm32f4xx_pwr.c **** 
  78:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of ODSWEN bit */
  79:./FWLIB/src/stm32f4xx_pwr.c **** #define ODSWEN_BitNumber         0x11
  80:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_ODSWEN_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (ODSWEN_BitNumber * 4))
  81:./FWLIB/src/stm32f4xx_pwr.c **** 
  82:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of MRLVDS bit */
  83:./FWLIB/src/stm32f4xx_pwr.c **** #define MRLVDS_BitNumber         0x0B
  84:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_MRLVDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (MRLVDS_BitNumber * 4))
  85:./FWLIB/src/stm32f4xx_pwr.c **** 
  86:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of LPLVDS bit */
  87:./FWLIB/src/stm32f4xx_pwr.c **** #define LPLVDS_BitNumber         0x0A
  88:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_LPLVDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (LPLVDS_BitNumber * 4))
ARM GAS  /tmp/cca6hA9x.s 			page 3


  89:./FWLIB/src/stm32f4xx_pwr.c **** 
  90:./FWLIB/src/stm32f4xx_pwr.c **** /* --- CSR Register ---*/
  91:./FWLIB/src/stm32f4xx_pwr.c **** 
  92:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of EWUP bit */
  93:./FWLIB/src/stm32f4xx_pwr.c **** #define CSR_OFFSET               (PWR_OFFSET + 0x04)
  94:./FWLIB/src/stm32f4xx_pwr.c **** #define EWUP_BitNumber           0x08
  95:./FWLIB/src/stm32f4xx_pwr.c **** #define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
  96:./FWLIB/src/stm32f4xx_pwr.c **** 
  97:./FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of BRE bit */
  98:./FWLIB/src/stm32f4xx_pwr.c **** #define BRE_BitNumber            0x09
  99:./FWLIB/src/stm32f4xx_pwr.c **** #define CSR_BRE_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (BRE_BitNumber * 4))
 100:./FWLIB/src/stm32f4xx_pwr.c **** 
 101:./FWLIB/src/stm32f4xx_pwr.c **** /* ------------------ PWR registers bit mask ------------------------ */
 102:./FWLIB/src/stm32f4xx_pwr.c **** 
 103:./FWLIB/src/stm32f4xx_pwr.c **** /* CR register bit mask */
 104:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_DS_MASK               ((uint32_t)0xFFFFF3FC)
 105:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
 106:./FWLIB/src/stm32f4xx_pwr.c **** #define CR_VOS_MASK              ((uint32_t)0xFFFF3FFF)
 107:./FWLIB/src/stm32f4xx_pwr.c **** 
 108:./FWLIB/src/stm32f4xx_pwr.c **** /* Private macro -------------------------------------------------------------*/
 109:./FWLIB/src/stm32f4xx_pwr.c **** /* Private variables ---------------------------------------------------------*/
 110:./FWLIB/src/stm32f4xx_pwr.c **** /* Private function prototypes -----------------------------------------------*/
 111:./FWLIB/src/stm32f4xx_pwr.c **** /* Private functions ---------------------------------------------------------*/
 112:./FWLIB/src/stm32f4xx_pwr.c **** 
 113:./FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Private_Functions
 114:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
 115:./FWLIB/src/stm32f4xx_pwr.c ****   */
 116:./FWLIB/src/stm32f4xx_pwr.c **** 
 117:./FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group1 Backup Domain Access function 
 118:./FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   Backup Domain Access function  
 119:./FWLIB/src/stm32f4xx_pwr.c ****  *
 120:./FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 121:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 122:./FWLIB/src/stm32f4xx_pwr.c ****                   ##### Backup Domain Access function #####
 123:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 124:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 125:./FWLIB/src/stm32f4xx_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data 
 126:./FWLIB/src/stm32f4xx_pwr.c ****       registers and backup SRAM) is protected against possible unwanted 
 127:./FWLIB/src/stm32f4xx_pwr.c ****       write accesses. 
 128:./FWLIB/src/stm32f4xx_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
 129:./FWLIB/src/stm32f4xx_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
 130:./FWLIB/src/stm32f4xx_pwr.c ****             RCC_APB1PeriphClockCmd() function.
 131:./FWLIB/src/stm32f4xx_pwr.c ****         (+) Enable access to RTC domain using the PWR_BackupAccessCmd() function.
 132:./FWLIB/src/stm32f4xx_pwr.c **** 
 133:./FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 134:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
 135:./FWLIB/src/stm32f4xx_pwr.c ****   */
 136:./FWLIB/src/stm32f4xx_pwr.c **** 
 137:./FWLIB/src/stm32f4xx_pwr.c **** /**
 138:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
 139:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  None
 140:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 141:./FWLIB/src/stm32f4xx_pwr.c ****   */
 142:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_DeInit(void)
 143:./FWLIB/src/stm32f4xx_pwr.c **** {
  28              		.loc 1 143 0
  29              		.cfi_startproc
ARM GAS  /tmp/cca6hA9x.s 			page 4


  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32 0000 08B5     		push	{r3, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 3, -8
  36              		.cfi_offset 14, -4
 144:./FWLIB/src/stm32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
  37              		.loc 1 144 0
  38 0002 0121     		movs	r1, #1
  39 0004 4FF08050 		mov	r0, #268435456
  40 0008 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  41              	.LVL0:
 145:./FWLIB/src/stm32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
  42              		.loc 1 145 0
  43 000c 0021     		movs	r1, #0
  44 000e 4FF08050 		mov	r0, #268435456
  45 0012 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  46              	.LVL1:
 146:./FWLIB/src/stm32f4xx_pwr.c **** }
  47              		.loc 1 146 0
  48 0016 08BD     		pop	{r3, pc}
  49              		.cfi_endproc
  50              	.LFE112:
  52              		.section	.text.PWR_BackupAccessCmd,"ax",%progbits
  53              		.align	1
  54              		.global	PWR_BackupAccessCmd
  55              		.syntax unified
  56              		.thumb
  57              		.thumb_func
  58              		.fpu fpv4-sp-d16
  60              	PWR_BackupAccessCmd:
  61              	.LFB113:
 147:./FWLIB/src/stm32f4xx_pwr.c **** 
 148:./FWLIB/src/stm32f4xx_pwr.c **** /**
 149:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables access to the backup domain (RTC registers, RTC 
 150:./FWLIB/src/stm32f4xx_pwr.c ****   *         backup data registers and backup SRAM).
 151:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
 152:./FWLIB/src/stm32f4xx_pwr.c ****   *         Backup Domain Access should be kept enabled.
 153:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the access to the backup domain.
 154:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 155:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 156:./FWLIB/src/stm32f4xx_pwr.c ****   */
 157:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_BackupAccessCmd(FunctionalState NewState)
 158:./FWLIB/src/stm32f4xx_pwr.c **** {
  62              		.loc 1 158 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 0
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67              	.LVL2:
 159:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 160:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 161:./FWLIB/src/stm32f4xx_pwr.c ****   
 162:./FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
  68              		.loc 1 162 0
  69 0000 014B     		ldr	r3, .L4
ARM GAS  /tmp/cca6hA9x.s 			page 5


  70 0002 1860     		str	r0, [r3]
 163:./FWLIB/src/stm32f4xx_pwr.c **** }
  71              		.loc 1 163 0
  72 0004 7047     		bx	lr
  73              	.L5:
  74 0006 00BF     		.align	2
  75              	.L4:
  76 0008 20000E42 		.word	1108213792
  77              		.cfi_endproc
  78              	.LFE113:
  80              		.section	.text.PWR_PVDLevelConfig,"ax",%progbits
  81              		.align	1
  82              		.global	PWR_PVDLevelConfig
  83              		.syntax unified
  84              		.thumb
  85              		.thumb_func
  86              		.fpu fpv4-sp-d16
  88              	PWR_PVDLevelConfig:
  89              	.LFB114:
 164:./FWLIB/src/stm32f4xx_pwr.c **** 
 165:./FWLIB/src/stm32f4xx_pwr.c **** /**
 166:./FWLIB/src/stm32f4xx_pwr.c ****   * @}
 167:./FWLIB/src/stm32f4xx_pwr.c ****   */
 168:./FWLIB/src/stm32f4xx_pwr.c **** 
 169:./FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group2 PVD configuration functions
 170:./FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   PVD configuration functions 
 171:./FWLIB/src/stm32f4xx_pwr.c ****  *
 172:./FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 173:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 174:./FWLIB/src/stm32f4xx_pwr.c ****                     ##### PVD configuration functions #####
 175:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 176:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 177:./FWLIB/src/stm32f4xx_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a 
 178:./FWLIB/src/stm32f4xx_pwr.c ****           threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 179:./FWLIB/src/stm32f4xx_pwr.c ****       (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower 
 180:./FWLIB/src/stm32f4xx_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI 
 181:./FWLIB/src/stm32f4xx_pwr.c ****           line16 and can generate an interrupt if enabled through the EXTI registers.
 182:./FWLIB/src/stm32f4xx_pwr.c ****       (+) The PVD is stopped in Standby mode.
 183:./FWLIB/src/stm32f4xx_pwr.c **** 
 184:./FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 185:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
 186:./FWLIB/src/stm32f4xx_pwr.c ****   */
 187:./FWLIB/src/stm32f4xx_pwr.c **** 
 188:./FWLIB/src/stm32f4xx_pwr.c **** /**
 189:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 190:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_PVDLevel: specifies the PVD detection level
 191:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 192:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_0
 193:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_1
 194:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_2
 195:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_3
 196:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_4
 197:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_5
 198:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_6
 199:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_7
 200:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 201:./FWLIB/src/stm32f4xx_pwr.c ****   *         more details about the voltage threshold corresponding to each 
ARM GAS  /tmp/cca6hA9x.s 			page 6


 202:./FWLIB/src/stm32f4xx_pwr.c ****   *         detection level.
 203:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 204:./FWLIB/src/stm32f4xx_pwr.c ****   */
 205:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
 206:./FWLIB/src/stm32f4xx_pwr.c **** {
  90              		.loc 1 206 0
  91              		.cfi_startproc
  92              		@ args = 0, pretend = 0, frame = 0
  93              		@ frame_needed = 0, uses_anonymous_args = 0
  94              		@ link register save eliminated.
  95              	.LVL3:
 207:./FWLIB/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 208:./FWLIB/src/stm32f4xx_pwr.c ****   
 209:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 210:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
 211:./FWLIB/src/stm32f4xx_pwr.c ****   
 212:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
  96              		.loc 1 212 0
  97 0000 034A     		ldr	r2, .L7
  98 0002 1368     		ldr	r3, [r2]
  99              	.LVL4:
 213:./FWLIB/src/stm32f4xx_pwr.c ****   
 214:./FWLIB/src/stm32f4xx_pwr.c ****   /* Clear PLS[7:5] bits */
 215:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg &= CR_PLS_MASK;
 100              		.loc 1 215 0
 101 0004 23F0E003 		bic	r3, r3, #224
 102              	.LVL5:
 216:./FWLIB/src/stm32f4xx_pwr.c ****   
 217:./FWLIB/src/stm32f4xx_pwr.c ****   /* Set PLS[7:5] bits according to PWR_PVDLevel value */
 218:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_PVDLevel;
 103              		.loc 1 218 0
 104 0008 1843     		orrs	r0, r0, r3
 105              	.LVL6:
 219:./FWLIB/src/stm32f4xx_pwr.c ****   
 220:./FWLIB/src/stm32f4xx_pwr.c ****   /* Store the new value */
 221:./FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 106              		.loc 1 221 0
 107 000a 1060     		str	r0, [r2]
 222:./FWLIB/src/stm32f4xx_pwr.c **** }
 108              		.loc 1 222 0
 109 000c 7047     		bx	lr
 110              	.L8:
 111 000e 00BF     		.align	2
 112              	.L7:
 113 0010 00700040 		.word	1073770496
 114              		.cfi_endproc
 115              	.LFE114:
 117              		.section	.text.PWR_PVDCmd,"ax",%progbits
 118              		.align	1
 119              		.global	PWR_PVDCmd
 120              		.syntax unified
 121              		.thumb
 122              		.thumb_func
 123              		.fpu fpv4-sp-d16
 125              	PWR_PVDCmd:
 126              	.LFB115:
 223:./FWLIB/src/stm32f4xx_pwr.c **** 
ARM GAS  /tmp/cca6hA9x.s 			page 7


 224:./FWLIB/src/stm32f4xx_pwr.c **** /**
 225:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Power Voltage Detector(PVD).
 226:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the PVD.
 227:./FWLIB/src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 228:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 229:./FWLIB/src/stm32f4xx_pwr.c ****   */
 230:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_PVDCmd(FunctionalState NewState)
 231:./FWLIB/src/stm32f4xx_pwr.c **** {
 127              		.loc 1 231 0
 128              		.cfi_startproc
 129              		@ args = 0, pretend = 0, frame = 0
 130              		@ frame_needed = 0, uses_anonymous_args = 0
 131              		@ link register save eliminated.
 132              	.LVL7:
 232:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 233:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 234:./FWLIB/src/stm32f4xx_pwr.c ****   
 235:./FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 133              		.loc 1 235 0
 134 0000 014B     		ldr	r3, .L10
 135 0002 1860     		str	r0, [r3]
 236:./FWLIB/src/stm32f4xx_pwr.c **** }
 136              		.loc 1 236 0
 137 0004 7047     		bx	lr
 138              	.L11:
 139 0006 00BF     		.align	2
 140              	.L10:
 141 0008 10000E42 		.word	1108213776
 142              		.cfi_endproc
 143              	.LFE115:
 145              		.section	.text.PWR_WakeUpPinCmd,"ax",%progbits
 146              		.align	1
 147              		.global	PWR_WakeUpPinCmd
 148              		.syntax unified
 149              		.thumb
 150              		.thumb_func
 151              		.fpu fpv4-sp-d16
 153              	PWR_WakeUpPinCmd:
 154              	.LFB116:
 237:./FWLIB/src/stm32f4xx_pwr.c **** 
 238:./FWLIB/src/stm32f4xx_pwr.c **** /**
 239:./FWLIB/src/stm32f4xx_pwr.c ****   * @}
 240:./FWLIB/src/stm32f4xx_pwr.c ****   */
 241:./FWLIB/src/stm32f4xx_pwr.c **** 
 242:./FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group3 WakeUp pin configuration functions
 243:./FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   WakeUp pin configuration functions 
 244:./FWLIB/src/stm32f4xx_pwr.c ****  *
 245:./FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 246:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 247:./FWLIB/src/stm32f4xx_pwr.c ****                  ##### WakeUp pin configuration functions #####
 248:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 249:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 250:./FWLIB/src/stm32f4xx_pwr.c ****       (+) WakeUp pin is used to wakeup the system from Standby mode. This pin is 
 251:./FWLIB/src/stm32f4xx_pwr.c ****           forced in input pull down configuration and is active on rising edges.
 252:./FWLIB/src/stm32f4xx_pwr.c ****       (+) There is only one WakeUp pin: WakeUp Pin 1 on PA.00.
 253:./FWLIB/src/stm32f4xx_pwr.c **** 
 254:./FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
ARM GAS  /tmp/cca6hA9x.s 			page 8


 255:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
 256:./FWLIB/src/stm32f4xx_pwr.c ****   */
 257:./FWLIB/src/stm32f4xx_pwr.c **** 
 258:./FWLIB/src/stm32f4xx_pwr.c **** /**
 259:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin functionality.
 260:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin functionality.
 261:./FWLIB/src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 262:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 263:./FWLIB/src/stm32f4xx_pwr.c ****   */
 264:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_WakeUpPinCmd(FunctionalState NewState)
 265:./FWLIB/src/stm32f4xx_pwr.c **** {
 155              		.loc 1 265 0
 156              		.cfi_startproc
 157              		@ args = 0, pretend = 0, frame = 0
 158              		@ frame_needed = 0, uses_anonymous_args = 0
 159              		@ link register save eliminated.
 160              	.LVL8:
 266:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */  
 267:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 268:./FWLIB/src/stm32f4xx_pwr.c **** 
 269:./FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 161              		.loc 1 269 0
 162 0000 014B     		ldr	r3, .L13
 163 0002 1860     		str	r0, [r3]
 270:./FWLIB/src/stm32f4xx_pwr.c **** }
 164              		.loc 1 270 0
 165 0004 7047     		bx	lr
 166              	.L14:
 167 0006 00BF     		.align	2
 168              	.L13:
 169 0008 A0000E42 		.word	1108213920
 170              		.cfi_endproc
 171              	.LFE116:
 173              		.section	.text.PWR_BackupRegulatorCmd,"ax",%progbits
 174              		.align	1
 175              		.global	PWR_BackupRegulatorCmd
 176              		.syntax unified
 177              		.thumb
 178              		.thumb_func
 179              		.fpu fpv4-sp-d16
 181              	PWR_BackupRegulatorCmd:
 182              	.LFB117:
 271:./FWLIB/src/stm32f4xx_pwr.c **** 
 272:./FWLIB/src/stm32f4xx_pwr.c **** /**
 273:./FWLIB/src/stm32f4xx_pwr.c ****   * @}
 274:./FWLIB/src/stm32f4xx_pwr.c ****   */
 275:./FWLIB/src/stm32f4xx_pwr.c **** 
 276:./FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group4 Main and Backup Regulators configuration functions
 277:./FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   Main and Backup Regulators configuration functions 
 278:./FWLIB/src/stm32f4xx_pwr.c ****  *
 279:./FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 280:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 281:./FWLIB/src/stm32f4xx_pwr.c ****           ##### Main and Backup Regulators configuration functions #####
 282:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 283:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 284:./FWLIB/src/stm32f4xx_pwr.c ****       (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
 285:./FWLIB/src/stm32f4xx_pwr.c ****           the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
ARM GAS  /tmp/cca6hA9x.s 			page 9


 286:./FWLIB/src/stm32f4xx_pwr.c ****           retained even in Standby or VBAT mode when the low power backup regulator
 287:./FWLIB/src/stm32f4xx_pwr.c ****           is enabled. It can be considered as an internal EEPROM when VBAT is 
 288:./FWLIB/src/stm32f4xx_pwr.c ****           always present. You can use the PWR_BackupRegulatorCmd() function to 
 289:./FWLIB/src/stm32f4xx_pwr.c ****           enable the low power backup regulator and use the PWR_GetFlagStatus
 290:./FWLIB/src/stm32f4xx_pwr.c ****           (PWR_FLAG_BRR) to check if it is ready or not. 
 291:./FWLIB/src/stm32f4xx_pwr.c **** 
 292:./FWLIB/src/stm32f4xx_pwr.c ****       (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
 293:./FWLIB/src/stm32f4xx_pwr.c ****           the backup SRAM is powered from VDD which replaces the VBAT power supply to 
 294:./FWLIB/src/stm32f4xx_pwr.c ****           save battery life.
 295:./FWLIB/src/stm32f4xx_pwr.c **** 
 296:./FWLIB/src/stm32f4xx_pwr.c ****       (+) The backup SRAM is not mass erased by an tamper event. It is read 
 297:./FWLIB/src/stm32f4xx_pwr.c ****           protected to prevent confidential data, such as cryptographic private 
 298:./FWLIB/src/stm32f4xx_pwr.c ****           key, from being accessed. The backup SRAM can be erased only through 
 299:./FWLIB/src/stm32f4xx_pwr.c ****           the Flash interface when a protection level change from level 1 to 
 300:./FWLIB/src/stm32f4xx_pwr.c ****           level 0 is requested. 
 301:./FWLIB/src/stm32f4xx_pwr.c ****       -@- Refer to the description of Read protection (RDP) in the reference manual.
 302:./FWLIB/src/stm32f4xx_pwr.c **** 
 303:./FWLIB/src/stm32f4xx_pwr.c ****       (+) The main internal regulator can be configured to have a tradeoff between 
 304:./FWLIB/src/stm32f4xx_pwr.c ****           performance and power consumption when the device does not operate at 
 305:./FWLIB/src/stm32f4xx_pwr.c ****           the maximum frequency. 
 306:./FWLIB/src/stm32f4xx_pwr.c ****       (+) For STM32F405xx/407xx and STM32F415xx/417xx  Devices, the regulator can be     
 307:./FWLIB/src/stm32f4xx_pwr.c ****           configured on the fly through PWR_MainRegulatorModeConfig() function which  
 308:./FWLIB/src/stm32f4xx_pwr.c ****           configure VOS bit in PWR_CR register:
 309:./FWLIB/src/stm32f4xx_pwr.c ****         (++) When this bit is set (Regulator voltage output Scale 1 mode selected) 
 310:./FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 168 MHz. 
 311:./FWLIB/src/stm32f4xx_pwr.c ****         (++) When this bit is reset (Regulator voltage output Scale 2 mode selected) 
 312:./FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 144 MHz.
 313:./FWLIB/src/stm32f4xx_pwr.c ****              
 314:./FWLIB/src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, the regulator can be configured through    
 315:./FWLIB/src/stm32f4xx_pwr.c ****            PWR_MainRegulatorModeConfig() function which configure VOS[1:0] bits in
 316:./FWLIB/src/stm32f4xx_pwr.c ****            PWR_CR register:  
 317:./FWLIB/src/stm32f4xx_pwr.c ****            which configure VOS[1:0] bits in PWR_CR register: 
 318:./FWLIB/src/stm32f4xx_pwr.c ****         (++) When VOS[1:0] = 11 (Regulator voltage output Scale 1 mode selected) 
 319:./FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 168 MHz. 
 320:./FWLIB/src/stm32f4xx_pwr.c ****         (++) When VOS[1:0] = 10 (Regulator voltage output Scale 2 mode selected) 
 321:./FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 144 MHz.  
 322:./FWLIB/src/stm32f4xx_pwr.c ****         (++) When VOS[1:0] = 01 (Regulator voltage output Scale 3 mode selected) 
 323:./FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 120 MHz. 
 324:./FWLIB/src/stm32f4xx_pwr.c ****                           
 325:./FWLIB/src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, the scale can be modified only when the PLL 
 326:./FWLIB/src/stm32f4xx_pwr.c ****            is OFF and the HSI or HSE clock source is selected as system clock. 
 327:./FWLIB/src/stm32f4xx_pwr.c ****            The new value programmed is active only when the PLL is ON.
 328:./FWLIB/src/stm32f4xx_pwr.c ****            When the PLL is OFF, the voltage scale 3 is automatically selected. 
 329:./FWLIB/src/stm32f4xx_pwr.c ****         Refer to the datasheets for more details.
 330:./FWLIB/src/stm32f4xx_pwr.c ****         
 331:./FWLIB/src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, in Run mode: the main regulator has
 332:./FWLIB/src/stm32f4xx_pwr.c ****            2 operating modes available:
 333:./FWLIB/src/stm32f4xx_pwr.c ****         (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
 334:./FWLIB/src/stm32f4xx_pwr.c ****              voltage scaling (scale 1, scale 2 or scale 3)
 335:./FWLIB/src/stm32f4xx_pwr.c ****         (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
 336:./FWLIB/src/stm32f4xx_pwr.c ****             higher frequency than the normal mode for a given voltage scaling (scale 1,  
 337:./FWLIB/src/stm32f4xx_pwr.c ****             scale 2 or scale 3). This mode is enabled through PWR_OverDriveCmd() function and
 338:./FWLIB/src/stm32f4xx_pwr.c ****             PWR_OverDriveSWCmd() function, to enter or exit from Over-drive mode please follow 
 339:./FWLIB/src/stm32f4xx_pwr.c ****             the sequence described in Reference manual.
 340:./FWLIB/src/stm32f4xx_pwr.c ****              
 341:./FWLIB/src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, in Stop mode: the main regulator or low power regulator 
 342:./FWLIB/src/stm32f4xx_pwr.c ****            supplies a low power voltage to the 1.2V domain, thus preserving the content of register
ARM GAS  /tmp/cca6hA9x.s 			page 10


 343:./FWLIB/src/stm32f4xx_pwr.c ****            and internal SRAM. 2 operating modes are available:
 344:./FWLIB/src/stm32f4xx_pwr.c ****          (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
 345:./FWLIB/src/stm32f4xx_pwr.c ****               available when the main regulator or the low power regulator is used in Scale 3 or 
 346:./FWLIB/src/stm32f4xx_pwr.c ****               low voltage mode.
 347:./FWLIB/src/stm32f4xx_pwr.c ****          (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is 
 348:./FWLIB/src/stm32f4xx_pwr.c ****               available when the main regulator or the low power regulator is in low voltage mode.
 349:./FWLIB/src/stm32f4xx_pwr.c ****               This mode is enabled through PWR_UnderDriveCmd() function.
 350:./FWLIB/src/stm32f4xx_pwr.c ****             
 351:./FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 352:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
 353:./FWLIB/src/stm32f4xx_pwr.c ****   */
 354:./FWLIB/src/stm32f4xx_pwr.c **** 
 355:./FWLIB/src/stm32f4xx_pwr.c **** /**
 356:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Backup Regulator.
 357:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Backup Regulator.
 358:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 359:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 360:./FWLIB/src/stm32f4xx_pwr.c ****   */
 361:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_BackupRegulatorCmd(FunctionalState NewState)
 362:./FWLIB/src/stm32f4xx_pwr.c **** {
 183              		.loc 1 362 0
 184              		.cfi_startproc
 185              		@ args = 0, pretend = 0, frame = 0
 186              		@ frame_needed = 0, uses_anonymous_args = 0
 187              		@ link register save eliminated.
 188              	.LVL9:
 363:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 364:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 365:./FWLIB/src/stm32f4xx_pwr.c **** 
 366:./FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
 189              		.loc 1 366 0
 190 0000 014B     		ldr	r3, .L16
 191 0002 1860     		str	r0, [r3]
 367:./FWLIB/src/stm32f4xx_pwr.c **** }
 192              		.loc 1 367 0
 193 0004 7047     		bx	lr
 194              	.L17:
 195 0006 00BF     		.align	2
 196              	.L16:
 197 0008 A4000E42 		.word	1108213924
 198              		.cfi_endproc
 199              	.LFE117:
 201              		.section	.text.PWR_MainRegulatorModeConfig,"ax",%progbits
 202              		.align	1
 203              		.global	PWR_MainRegulatorModeConfig
 204              		.syntax unified
 205              		.thumb
 206              		.thumb_func
 207              		.fpu fpv4-sp-d16
 209              	PWR_MainRegulatorModeConfig:
 210              	.LFB118:
 368:./FWLIB/src/stm32f4xx_pwr.c **** 
 369:./FWLIB/src/stm32f4xx_pwr.c **** /**
 370:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Configures the main internal regulator output voltage.
 371:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator_Voltage: specifies the regulator output voltage to achieve
 372:./FWLIB/src/stm32f4xx_pwr.c ****   *         a tradeoff between performance and power consumption when the device does
 373:./FWLIB/src/stm32f4xx_pwr.c ****   *         not operate at the maximum frequency (refer to the datasheets for more details).
ARM GAS  /tmp/cca6hA9x.s 			page 11


 374:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 375:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale1: Regulator voltage output Scale 1 mode, 
 376:./FWLIB/src/stm32f4xx_pwr.c ****   *                                                System frequency up to 168 MHz. 
 377:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
 378:./FWLIB/src/stm32f4xx_pwr.c ****   *                                                System frequency up to 144 MHz.    
 379:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale3: Regulator voltage output Scale 3 mode, 
 380:./FWLIB/src/stm32f4xx_pwr.c ****   *                                                System frequency up to 120 MHz (only for STM32F4
 381:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 382:./FWLIB/src/stm32f4xx_pwr.c ****   */
 383:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
 384:./FWLIB/src/stm32f4xx_pwr.c **** {
 211              		.loc 1 384 0
 212              		.cfi_startproc
 213              		@ args = 0, pretend = 0, frame = 0
 214              		@ frame_needed = 0, uses_anonymous_args = 0
 215              		@ link register save eliminated.
 216              	.LVL10:
 385:./FWLIB/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 386:./FWLIB/src/stm32f4xx_pwr.c **** 	
 387:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 388:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
 389:./FWLIB/src/stm32f4xx_pwr.c **** 
 390:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 217              		.loc 1 390 0
 218 0000 034A     		ldr	r2, .L19
 219 0002 1368     		ldr	r3, [r2]
 220              	.LVL11:
 391:./FWLIB/src/stm32f4xx_pwr.c ****   
 392:./FWLIB/src/stm32f4xx_pwr.c ****   /* Clear VOS[15:14] bits */
 393:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg &= CR_VOS_MASK;
 221              		.loc 1 393 0
 222 0004 23F44043 		bic	r3, r3, #49152
 223              	.LVL12:
 394:./FWLIB/src/stm32f4xx_pwr.c ****   
 395:./FWLIB/src/stm32f4xx_pwr.c ****   /* Set VOS[15:14] bits according to PWR_Regulator_Voltage value */
 396:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator_Voltage;
 224              		.loc 1 396 0
 225 0008 1843     		orrs	r0, r0, r3
 226              	.LVL13:
 397:./FWLIB/src/stm32f4xx_pwr.c ****   
 398:./FWLIB/src/stm32f4xx_pwr.c ****   /* Store the new value */
 399:./FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 227              		.loc 1 399 0
 228 000a 1060     		str	r0, [r2]
 400:./FWLIB/src/stm32f4xx_pwr.c **** }
 229              		.loc 1 400 0
 230 000c 7047     		bx	lr
 231              	.L20:
 232 000e 00BF     		.align	2
 233              	.L19:
 234 0010 00700040 		.word	1073770496
 235              		.cfi_endproc
 236              	.LFE118:
 238              		.section	.text.PWR_OverDriveCmd,"ax",%progbits
 239              		.align	1
 240              		.global	PWR_OverDriveCmd
 241              		.syntax unified
ARM GAS  /tmp/cca6hA9x.s 			page 12


 242              		.thumb
 243              		.thumb_func
 244              		.fpu fpv4-sp-d16
 246              	PWR_OverDriveCmd:
 247              	.LFB119:
 401:./FWLIB/src/stm32f4xx_pwr.c **** 
 402:./FWLIB/src/stm32f4xx_pwr.c **** /**
 403:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Over-Drive.
 404:./FWLIB/src/stm32f4xx_pwr.c ****   * 
 405:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   This function can be used only for STM32F42xxx/STM3243xxx devices.
 406:./FWLIB/src/stm32f4xx_pwr.c ****   *         This mode allows the CPU and the core logic to operate at a higher frequency
 407:./FWLIB/src/stm32f4xx_pwr.c ****   *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
 408:./FWLIB/src/stm32f4xx_pwr.c ****   * 
 409:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
 410:./FWLIB/src/stm32f4xx_pwr.c ****   *          critical tasks and when the system clock source is either HSI or HSE. 
 411:./FWLIB/src/stm32f4xx_pwr.c ****   *          During the Over-drive switch activation, no peripheral clocks should be enabled.   
 412:./FWLIB/src/stm32f4xx_pwr.c ****   *          The peripheral clocks must be enabled once the Over-drive mode is activated.
 413:./FWLIB/src/stm32f4xx_pwr.c ****   *            
 414:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Over Drive mode.
 415:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 416:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 417:./FWLIB/src/stm32f4xx_pwr.c ****   */
 418:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_OverDriveCmd(FunctionalState NewState)
 419:./FWLIB/src/stm32f4xx_pwr.c **** {
 248              		.loc 1 419 0
 249              		.cfi_startproc
 250              		@ args = 0, pretend = 0, frame = 0
 251              		@ frame_needed = 0, uses_anonymous_args = 0
 252              		@ link register save eliminated.
 253              	.LVL14:
 420:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 421:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 422:./FWLIB/src/stm32f4xx_pwr.c ****   
 423:./FWLIB/src/stm32f4xx_pwr.c ****   /* Set/Reset the ODEN bit to enable/disable the Over Drive mode */
 424:./FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_ODEN_BB = (uint32_t)NewState;
 254              		.loc 1 424 0
 255 0000 014B     		ldr	r3, .L22
 256 0002 1860     		str	r0, [r3]
 425:./FWLIB/src/stm32f4xx_pwr.c **** }
 257              		.loc 1 425 0
 258 0004 7047     		bx	lr
 259              	.L23:
 260 0006 00BF     		.align	2
 261              	.L22:
 262 0008 40000E42 		.word	1108213824
 263              		.cfi_endproc
 264              	.LFE119:
 266              		.section	.text.PWR_OverDriveSWCmd,"ax",%progbits
 267              		.align	1
 268              		.global	PWR_OverDriveSWCmd
 269              		.syntax unified
 270              		.thumb
 271              		.thumb_func
 272              		.fpu fpv4-sp-d16
 274              	PWR_OverDriveSWCmd:
 275              	.LFB120:
 426:./FWLIB/src/stm32f4xx_pwr.c **** 
ARM GAS  /tmp/cca6hA9x.s 			page 13


 427:./FWLIB/src/stm32f4xx_pwr.c **** /**
 428:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Over-Drive switching.
 429:./FWLIB/src/stm32f4xx_pwr.c ****   * 
 430:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   This function can be used only for STM32F42xxx/STM3243xxx devices. 
 431:./FWLIB/src/stm32f4xx_pwr.c ****   *       
 432:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Over Drive switching mode.
 433:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 434:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 435:./FWLIB/src/stm32f4xx_pwr.c ****   */
 436:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_OverDriveSWCmd(FunctionalState NewState)
 437:./FWLIB/src/stm32f4xx_pwr.c **** {
 276              		.loc 1 437 0
 277              		.cfi_startproc
 278              		@ args = 0, pretend = 0, frame = 0
 279              		@ frame_needed = 0, uses_anonymous_args = 0
 280              		@ link register save eliminated.
 281              	.LVL15:
 438:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 439:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 440:./FWLIB/src/stm32f4xx_pwr.c **** 
 441:./FWLIB/src/stm32f4xx_pwr.c ****   /* Set/Reset the ODSWEN bit to enable/disable the Over Drive switching mode */
 442:./FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_ODSWEN_BB = (uint32_t)NewState;
 282              		.loc 1 442 0
 283 0000 014B     		ldr	r3, .L25
 284 0002 1860     		str	r0, [r3]
 443:./FWLIB/src/stm32f4xx_pwr.c **** }
 285              		.loc 1 443 0
 286 0004 7047     		bx	lr
 287              	.L26:
 288 0006 00BF     		.align	2
 289              	.L25:
 290 0008 44000E42 		.word	1108213828
 291              		.cfi_endproc
 292              	.LFE120:
 294              		.section	.text.PWR_UnderDriveCmd,"ax",%progbits
 295              		.align	1
 296              		.global	PWR_UnderDriveCmd
 297              		.syntax unified
 298              		.thumb
 299              		.thumb_func
 300              		.fpu fpv4-sp-d16
 302              	PWR_UnderDriveCmd:
 303              	.LFB121:
 444:./FWLIB/src/stm32f4xx_pwr.c **** 
 445:./FWLIB/src/stm32f4xx_pwr.c **** /**
 446:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief   Enables or disables the Under-Drive mode.
 447:./FWLIB/src/stm32f4xx_pwr.c ****   * 
 448:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   This function can be used only for STM32F42xxx/STM3243xxx devices.
 449:./FWLIB/src/stm32f4xx_pwr.c ****   * @note    This mode is enabled only with STOP low power mode.
 450:./FWLIB/src/stm32f4xx_pwr.c ****   *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
 451:./FWLIB/src/stm32f4xx_pwr.c ****   *          mode is only available when the main regulator or the low power regulator 
 452:./FWLIB/src/stm32f4xx_pwr.c ****   *          is in low voltage mode
 453:./FWLIB/src/stm32f4xx_pwr.c ****   *        
 454:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   If the Under-drive mode was enabled, it is automatically disabled after 
 455:./FWLIB/src/stm32f4xx_pwr.c ****   *         exiting Stop mode. 
 456:./FWLIB/src/stm32f4xx_pwr.c ****   *         When the voltage regulator operates in Under-drive mode, an additional  
 457:./FWLIB/src/stm32f4xx_pwr.c ****   *         startup delay is induced when waking up from Stop mode.
ARM GAS  /tmp/cca6hA9x.s 			page 14


 458:./FWLIB/src/stm32f4xx_pwr.c ****   *                    
 459:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Under Drive mode.
 460:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 461:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 462:./FWLIB/src/stm32f4xx_pwr.c ****   */
 463:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_UnderDriveCmd(FunctionalState NewState)
 464:./FWLIB/src/stm32f4xx_pwr.c **** {
 304              		.loc 1 464 0
 305              		.cfi_startproc
 306              		@ args = 0, pretend = 0, frame = 0
 307              		@ frame_needed = 0, uses_anonymous_args = 0
 308              		@ link register save eliminated.
 309              	.LVL16:
 465:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 466:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 467:./FWLIB/src/stm32f4xx_pwr.c **** 
 468:./FWLIB/src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 310              		.loc 1 468 0
 311 0000 28B9     		cbnz	r0, .L30
 469:./FWLIB/src/stm32f4xx_pwr.c ****   {
 470:./FWLIB/src/stm32f4xx_pwr.c ****     /* Set the UDEN[1:0] bits to enable the Under Drive mode */
 471:./FWLIB/src/stm32f4xx_pwr.c ****     PWR->CR |= (uint32_t)PWR_CR_UDEN;
 472:./FWLIB/src/stm32f4xx_pwr.c ****   }
 473:./FWLIB/src/stm32f4xx_pwr.c ****   else
 474:./FWLIB/src/stm32f4xx_pwr.c ****   {
 475:./FWLIB/src/stm32f4xx_pwr.c ****     /* Reset the UDEN[1:0] bits to disable the Under Drive mode */
 476:./FWLIB/src/stm32f4xx_pwr.c ****     PWR->CR &= (uint32_t)(~PWR_CR_UDEN);
 312              		.loc 1 476 0
 313 0002 064A     		ldr	r2, .L31
 314 0004 1368     		ldr	r3, [r2]
 315 0006 23F44023 		bic	r3, r3, #786432
 316 000a 1360     		str	r3, [r2]
 477:./FWLIB/src/stm32f4xx_pwr.c ****   }
 478:./FWLIB/src/stm32f4xx_pwr.c **** }
 317              		.loc 1 478 0
 318 000c 7047     		bx	lr
 319              	.L30:
 471:./FWLIB/src/stm32f4xx_pwr.c ****   }
 320              		.loc 1 471 0
 321 000e 034A     		ldr	r2, .L31
 322 0010 1368     		ldr	r3, [r2]
 323 0012 43F44023 		orr	r3, r3, #786432
 324 0016 1360     		str	r3, [r2]
 325 0018 7047     		bx	lr
 326              	.L32:
 327 001a 00BF     		.align	2
 328              	.L31:
 329 001c 00700040 		.word	1073770496
 330              		.cfi_endproc
 331              	.LFE121:
 333              		.section	.text.PWR_MainRegulatorLowVoltageCmd,"ax",%progbits
 334              		.align	1
 335              		.global	PWR_MainRegulatorLowVoltageCmd
 336              		.syntax unified
 337              		.thumb
 338              		.thumb_func
 339              		.fpu fpv4-sp-d16
ARM GAS  /tmp/cca6hA9x.s 			page 15


 341              	PWR_MainRegulatorLowVoltageCmd:
 342              	.LFB122:
 479:./FWLIB/src/stm32f4xx_pwr.c **** 
 480:./FWLIB/src/stm32f4xx_pwr.c **** /**
 481:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief Enables or disables the Main Regulator low voltage mode.
 482:./FWLIB/src/stm32f4xx_pwr.c ****   *
 483:./FWLIB/src/stm32f4xx_pwr.c ****   * @note  This mode is only available for STM32F401xx/STM32F411xx devices.
 484:./FWLIB/src/stm32f4xx_pwr.c ****   *
 485:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Under Drive mode.
 486:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 487:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 488:./FWLIB/src/stm32f4xx_pwr.c ****   */
 489:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_MainRegulatorLowVoltageCmd(FunctionalState NewState)
 490:./FWLIB/src/stm32f4xx_pwr.c **** { 
 343              		.loc 1 490 0
 344              		.cfi_startproc
 345              		@ args = 0, pretend = 0, frame = 0
 346              		@ frame_needed = 0, uses_anonymous_args = 0
 347              		@ link register save eliminated.
 348              	.LVL17:
 491:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 492:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 493:./FWLIB/src/stm32f4xx_pwr.c ****   
 494:./FWLIB/src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 349              		.loc 1 494 0
 350 0000 18B9     		cbnz	r0, .L36
 495:./FWLIB/src/stm32f4xx_pwr.c ****   {
 496:./FWLIB/src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)ENABLE;
 497:./FWLIB/src/stm32f4xx_pwr.c ****   }
 498:./FWLIB/src/stm32f4xx_pwr.c ****   else
 499:./FWLIB/src/stm32f4xx_pwr.c ****   {
 500:./FWLIB/src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;
 351              		.loc 1 500 0
 352 0002 044B     		ldr	r3, .L37
 353 0004 0022     		movs	r2, #0
 354 0006 1A60     		str	r2, [r3]
 501:./FWLIB/src/stm32f4xx_pwr.c ****   }
 502:./FWLIB/src/stm32f4xx_pwr.c **** }
 355              		.loc 1 502 0
 356 0008 7047     		bx	lr
 357              	.L36:
 496:./FWLIB/src/stm32f4xx_pwr.c ****   }
 358              		.loc 1 496 0
 359 000a 024B     		ldr	r3, .L37
 360 000c 0122     		movs	r2, #1
 361 000e 1A60     		str	r2, [r3]
 362 0010 7047     		bx	lr
 363              	.L38:
 364 0012 00BF     		.align	2
 365              	.L37:
 366 0014 2C000E42 		.word	1108213804
 367              		.cfi_endproc
 368              	.LFE122:
 370              		.section	.text.PWR_LowRegulatorLowVoltageCmd,"ax",%progbits
 371              		.align	1
 372              		.global	PWR_LowRegulatorLowVoltageCmd
 373              		.syntax unified
ARM GAS  /tmp/cca6hA9x.s 			page 16


 374              		.thumb
 375              		.thumb_func
 376              		.fpu fpv4-sp-d16
 378              	PWR_LowRegulatorLowVoltageCmd:
 379              	.LFB123:
 503:./FWLIB/src/stm32f4xx_pwr.c **** 
 504:./FWLIB/src/stm32f4xx_pwr.c **** /**
 505:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief Enables or disables the Low Power Regulator low voltage mode.
 506:./FWLIB/src/stm32f4xx_pwr.c ****   *
 507:./FWLIB/src/stm32f4xx_pwr.c ****   * @note  This mode is only available for STM32F401xx/STM32F411xx devices.
 508:./FWLIB/src/stm32f4xx_pwr.c ****   *
 509:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Under Drive mode.
 510:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 511:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 512:./FWLIB/src/stm32f4xx_pwr.c ****   */
 513:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_LowRegulatorLowVoltageCmd(FunctionalState NewState)
 514:./FWLIB/src/stm32f4xx_pwr.c **** {
 380              		.loc 1 514 0
 381              		.cfi_startproc
 382              		@ args = 0, pretend = 0, frame = 0
 383              		@ frame_needed = 0, uses_anonymous_args = 0
 384              		@ link register save eliminated.
 385              	.LVL18:
 515:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 516:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 517:./FWLIB/src/stm32f4xx_pwr.c ****   
 518:./FWLIB/src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 386              		.loc 1 518 0
 387 0000 18B9     		cbnz	r0, .L42
 519:./FWLIB/src/stm32f4xx_pwr.c ****   {
 520:./FWLIB/src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)ENABLE;
 521:./FWLIB/src/stm32f4xx_pwr.c ****   }
 522:./FWLIB/src/stm32f4xx_pwr.c ****   else
 523:./FWLIB/src/stm32f4xx_pwr.c ****   {
 524:./FWLIB/src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)DISABLE;
 388              		.loc 1 524 0
 389 0002 044B     		ldr	r3, .L43
 390 0004 0022     		movs	r2, #0
 391 0006 1A60     		str	r2, [r3]
 525:./FWLIB/src/stm32f4xx_pwr.c ****   }
 526:./FWLIB/src/stm32f4xx_pwr.c **** }
 392              		.loc 1 526 0
 393 0008 7047     		bx	lr
 394              	.L42:
 520:./FWLIB/src/stm32f4xx_pwr.c ****   }
 395              		.loc 1 520 0
 396 000a 024B     		ldr	r3, .L43
 397 000c 0122     		movs	r2, #1
 398 000e 1A60     		str	r2, [r3]
 399 0010 7047     		bx	lr
 400              	.L44:
 401 0012 00BF     		.align	2
 402              	.L43:
 403 0014 28000E42 		.word	1108213800
 404              		.cfi_endproc
 405              	.LFE123:
 407              		.section	.text.PWR_FlashPowerDownCmd,"ax",%progbits
ARM GAS  /tmp/cca6hA9x.s 			page 17


 408              		.align	1
 409              		.global	PWR_FlashPowerDownCmd
 410              		.syntax unified
 411              		.thumb
 412              		.thumb_func
 413              		.fpu fpv4-sp-d16
 415              	PWR_FlashPowerDownCmd:
 416              	.LFB124:
 527:./FWLIB/src/stm32f4xx_pwr.c **** 
 528:./FWLIB/src/stm32f4xx_pwr.c **** /**
 529:./FWLIB/src/stm32f4xx_pwr.c ****   * @}
 530:./FWLIB/src/stm32f4xx_pwr.c ****   */
 531:./FWLIB/src/stm32f4xx_pwr.c **** 
 532:./FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group5 FLASH Power Down configuration functions
 533:./FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   FLASH Power Down configuration functions 
 534:./FWLIB/src/stm32f4xx_pwr.c ****  *
 535:./FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 536:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 537:./FWLIB/src/stm32f4xx_pwr.c ****              ##### FLASH Power Down configuration functions #####
 538:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 539:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 540:./FWLIB/src/stm32f4xx_pwr.c ****       (+) By setting the FPDS bit in the PWR_CR register by using the 
 541:./FWLIB/src/stm32f4xx_pwr.c ****           PWR_FlashPowerDownCmd() function, the Flash memory also enters power 
 542:./FWLIB/src/stm32f4xx_pwr.c ****           down mode when the device enters Stop mode. When the Flash memory 
 543:./FWLIB/src/stm32f4xx_pwr.c ****           is in power down mode, an additional startup delay is incurred when 
 544:./FWLIB/src/stm32f4xx_pwr.c ****           waking up from Stop mode.
 545:./FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 546:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
 547:./FWLIB/src/stm32f4xx_pwr.c ****   */
 548:./FWLIB/src/stm32f4xx_pwr.c **** 
 549:./FWLIB/src/stm32f4xx_pwr.c **** /**
 550:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Flash Power Down in STOP mode.
 551:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Flash power mode.
 552:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 553:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 554:./FWLIB/src/stm32f4xx_pwr.c ****   */
 555:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_FlashPowerDownCmd(FunctionalState NewState)
 556:./FWLIB/src/stm32f4xx_pwr.c **** {
 417              		.loc 1 556 0
 418              		.cfi_startproc
 419              		@ args = 0, pretend = 0, frame = 0
 420              		@ frame_needed = 0, uses_anonymous_args = 0
 421              		@ link register save eliminated.
 422              	.LVL19:
 557:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 558:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 559:./FWLIB/src/stm32f4xx_pwr.c **** 
 560:./FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
 423              		.loc 1 560 0
 424 0000 014B     		ldr	r3, .L46
 425 0002 1860     		str	r0, [r3]
 561:./FWLIB/src/stm32f4xx_pwr.c **** }
 426              		.loc 1 561 0
 427 0004 7047     		bx	lr
 428              	.L47:
 429 0006 00BF     		.align	2
 430              	.L46:
ARM GAS  /tmp/cca6hA9x.s 			page 18


 431 0008 24000E42 		.word	1108213796
 432              		.cfi_endproc
 433              	.LFE124:
 435              		.section	.text.PWR_EnterSTOPMode,"ax",%progbits
 436              		.align	1
 437              		.global	PWR_EnterSTOPMode
 438              		.syntax unified
 439              		.thumb
 440              		.thumb_func
 441              		.fpu fpv4-sp-d16
 443              	PWR_EnterSTOPMode:
 444              	.LFB125:
 562:./FWLIB/src/stm32f4xx_pwr.c **** 
 563:./FWLIB/src/stm32f4xx_pwr.c **** /**
 564:./FWLIB/src/stm32f4xx_pwr.c ****   * @}
 565:./FWLIB/src/stm32f4xx_pwr.c ****   */
 566:./FWLIB/src/stm32f4xx_pwr.c **** 
 567:./FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group6 Low Power modes configuration functions
 568:./FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   Low Power modes configuration functions 
 569:./FWLIB/src/stm32f4xx_pwr.c ****  *
 570:./FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 571:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 572:./FWLIB/src/stm32f4xx_pwr.c ****               ##### Low Power modes configuration functions #####
 573:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 574:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 575:./FWLIB/src/stm32f4xx_pwr.c ****       The devices feature 3 low-power modes:
 576:./FWLIB/src/stm32f4xx_pwr.c ****       (+) Sleep mode: Cortex-M4 core stopped, peripherals kept running.
 577:./FWLIB/src/stm32f4xx_pwr.c ****       (+) Stop mode: all clocks are stopped, regulator running, regulator 
 578:./FWLIB/src/stm32f4xx_pwr.c ****           in low power mode
 579:./FWLIB/src/stm32f4xx_pwr.c ****       (+) Standby mode: 1.2V domain powered off.
 580:./FWLIB/src/stm32f4xx_pwr.c ****    
 581:./FWLIB/src/stm32f4xx_pwr.c ****    *** Sleep mode ***
 582:./FWLIB/src/stm32f4xx_pwr.c ****    ==================
 583:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 584:./FWLIB/src/stm32f4xx_pwr.c ****       (+) Entry:
 585:./FWLIB/src/stm32f4xx_pwr.c ****         (++) The Sleep mode is entered by using the __WFI() or __WFE() functions.
 586:./FWLIB/src/stm32f4xx_pwr.c ****       (+) Exit:
 587:./FWLIB/src/stm32f4xx_pwr.c ****         (++) Any peripheral interrupt acknowledged by the nested vectored interrupt 
 588:./FWLIB/src/stm32f4xx_pwr.c ****              controller (NVIC) can wake up the device from Sleep mode.
 589:./FWLIB/src/stm32f4xx_pwr.c **** 
 590:./FWLIB/src/stm32f4xx_pwr.c ****    *** Stop mode ***
 591:./FWLIB/src/stm32f4xx_pwr.c ****    =================
 592:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 593:./FWLIB/src/stm32f4xx_pwr.c ****       In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
 594:./FWLIB/src/stm32f4xx_pwr.c ****       and the HSE RC oscillators are disabled. Internal SRAM and register contents 
 595:./FWLIB/src/stm32f4xx_pwr.c ****       are preserved.
 596:./FWLIB/src/stm32f4xx_pwr.c ****       The voltage regulator can be configured either in normal or low-power mode.
 597:./FWLIB/src/stm32f4xx_pwr.c ****       To minimize the consumption In Stop mode, FLASH can be powered off before 
 598:./FWLIB/src/stm32f4xx_pwr.c ****       entering the Stop mode. It can be switched on again by software after exiting 
 599:./FWLIB/src/stm32f4xx_pwr.c ****       the Stop mode using the PWR_FlashPowerDownCmd() function. 
 600:./FWLIB/src/stm32f4xx_pwr.c ****    
 601:./FWLIB/src/stm32f4xx_pwr.c ****       (+) Entry:
 602:./FWLIB/src/stm32f4xx_pwr.c ****         (++) The Stop mode is entered using the PWR_EnterSTOPMode(PWR_MainRegulator_ON) 
 603:./FWLIB/src/stm32f4xx_pwr.c ****              function with:
 604:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Main regulator ON.
 605:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Low Power regulator ON.
 606:./FWLIB/src/stm32f4xx_pwr.c ****       (+) Exit:
ARM GAS  /tmp/cca6hA9x.s 			page 19


 607:./FWLIB/src/stm32f4xx_pwr.c ****         (++) Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
 608:./FWLIB/src/stm32f4xx_pwr.c ****       
 609:./FWLIB/src/stm32f4xx_pwr.c ****    *** Standby mode ***
 610:./FWLIB/src/stm32f4xx_pwr.c ****    ====================
 611:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 612:./FWLIB/src/stm32f4xx_pwr.c ****       The Standby mode allows to achieve the lowest power consumption. It is based 
 613:./FWLIB/src/stm32f4xx_pwr.c ****       on the Cortex-M4 deepsleep mode, with the voltage regulator disabled. 
 614:./FWLIB/src/stm32f4xx_pwr.c ****       The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and 
 615:./FWLIB/src/stm32f4xx_pwr.c ****       the HSE oscillator are also switched off. SRAM and register contents are lost 
 616:./FWLIB/src/stm32f4xx_pwr.c ****       except for the RTC registers, RTC backup registers, backup SRAM and Standby 
 617:./FWLIB/src/stm32f4xx_pwr.c ****       circuitry.
 618:./FWLIB/src/stm32f4xx_pwr.c ****    
 619:./FWLIB/src/stm32f4xx_pwr.c ****       The voltage regulator is OFF.
 620:./FWLIB/src/stm32f4xx_pwr.c ****       
 621:./FWLIB/src/stm32f4xx_pwr.c ****       (+) Entry:
 622:./FWLIB/src/stm32f4xx_pwr.c ****         (++) The Standby mode is entered using the PWR_EnterSTANDBYMode() function.
 623:./FWLIB/src/stm32f4xx_pwr.c ****       (+) Exit:
 624:./FWLIB/src/stm32f4xx_pwr.c ****         (++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
 625:./FWLIB/src/stm32f4xx_pwr.c ****              tamper event, time-stamp event, external reset in NRST pin, IWDG reset.              
 626:./FWLIB/src/stm32f4xx_pwr.c **** 
 627:./FWLIB/src/stm32f4xx_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 628:./FWLIB/src/stm32f4xx_pwr.c ****    =============================================
 629:./FWLIB/src/stm32f4xx_pwr.c ****     [..]
 630:./FWLIB/src/stm32f4xx_pwr.c ****       The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
 631:./FWLIB/src/stm32f4xx_pwr.c ****       Wakeup event, a tamper event, a time-stamp event, or a comparator event, 
 632:./FWLIB/src/stm32f4xx_pwr.c ****       without depending on an external interrupt (Auto-wakeup mode).
 633:./FWLIB/src/stm32f4xx_pwr.c **** 
 634:./FWLIB/src/stm32f4xx_pwr.c ****       (#) RTC auto-wakeup (AWU) from the Stop mode
 635:./FWLIB/src/stm32f4xx_pwr.c ****        
 636:./FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to:
 637:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt 
 638:./FWLIB/src/stm32f4xx_pwr.c ****                 or Event modes) using the EXTI_Init() function.
 639:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 640:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 641:./FWLIB/src/stm32f4xx_pwr.c ****                 and RTC_AlarmCmd() functions.
 642:./FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
 643:./FWLIB/src/stm32f4xx_pwr.c ****              is necessary to:
 644:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the EXTI Line 21 to be sensitive to rising edges (Interrupt 
 645:./FWLIB/src/stm32f4xx_pwr.c ****                 or Event modes) using the EXTI_Init() function.
 646:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 647:./FWLIB/src/stm32f4xx_pwr.c ****                 function
 648:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to detect the tamper or time stamp event using the
 649:./FWLIB/src/stm32f4xx_pwr.c ****                 RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 650:./FWLIB/src/stm32f4xx_pwr.c ****                 functions.
 651:./FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to:
 652:./FWLIB/src/stm32f4xx_pwr.c ****            (+++) Configure the EXTI Line 22 to be sensitive to rising edges (Interrupt 
 653:./FWLIB/src/stm32f4xx_pwr.c ****                  or Event modes) using the EXTI_Init() function.
 654:./FWLIB/src/stm32f4xx_pwr.c ****            (+++) Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
 655:./FWLIB/src/stm32f4xx_pwr.c ****            (+++) Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig
 656:./FWLIB/src/stm32f4xx_pwr.c ****                  RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
 657:./FWLIB/src/stm32f4xx_pwr.c **** 
 658:./FWLIB/src/stm32f4xx_pwr.c ****       (#) RTC auto-wakeup (AWU) from the Standby mode
 659:./FWLIB/src/stm32f4xx_pwr.c ****    
 660:./FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC alarm event, it is necessary to:
 661:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 662:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 663:./FWLIB/src/stm32f4xx_pwr.c ****                 and RTC_AlarmCmd() functions.
ARM GAS  /tmp/cca6hA9x.s 			page 20


 664:./FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC Tamper or time stamp event, it 
 665:./FWLIB/src/stm32f4xx_pwr.c ****              is necessary to:
 666:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 667:./FWLIB/src/stm32f4xx_pwr.c ****                 function
 668:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to detect the tamper or time stamp event using the
 669:./FWLIB/src/stm32f4xx_pwr.c ****                 RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 670:./FWLIB/src/stm32f4xx_pwr.c ****                 functions.
 671:./FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC WakeUp event, it is necessary to:
 672:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
 673:./FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(
 674:./FWLIB/src/stm32f4xx_pwr.c ****                 RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
 675:./FWLIB/src/stm32f4xx_pwr.c **** 
 676:./FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 677:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
 678:./FWLIB/src/stm32f4xx_pwr.c ****   */
 679:./FWLIB/src/stm32f4xx_pwr.c **** 
 680:./FWLIB/src/stm32f4xx_pwr.c **** /**
 681:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enters STOP mode.
 682:./FWLIB/src/stm32f4xx_pwr.c ****   *   
 683:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 684:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
 685:./FWLIB/src/stm32f4xx_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 686:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   When the voltage regulator operates in low power mode, an additional 
 687:./FWLIB/src/stm32f4xx_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 688:./FWLIB/src/stm32f4xx_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption 
 689:./FWLIB/src/stm32f4xx_pwr.c ****   *         is higher although the startup time is reduced.
 690:./FWLIB/src/stm32f4xx_pwr.c ****   *     
 691:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 692:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 693:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_MainRegulator_ON: STOP mode with regulator ON
 694:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_LowPowerRegulator_ON: STOP mode with low power regulator ON
 695:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 696:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 697:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 698:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 699:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 700:./FWLIB/src/stm32f4xx_pwr.c ****   */
 701:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
 702:./FWLIB/src/stm32f4xx_pwr.c **** {
 445              		.loc 1 702 0
 446              		.cfi_startproc
 447              		@ args = 0, pretend = 0, frame = 0
 448              		@ frame_needed = 0, uses_anonymous_args = 0
 449              		@ link register save eliminated.
 450              	.LVL20:
 703:./FWLIB/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 704:./FWLIB/src/stm32f4xx_pwr.c ****   
 705:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 706:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR(PWR_Regulator));
 707:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 708:./FWLIB/src/stm32f4xx_pwr.c ****   
 709:./FWLIB/src/stm32f4xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 710:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 451              		.loc 1 710 0
 452 0000 0B4A     		ldr	r2, .L52
 453 0002 1368     		ldr	r3, [r2]
 454              	.LVL21:
ARM GAS  /tmp/cca6hA9x.s 			page 21


 711:./FWLIB/src/stm32f4xx_pwr.c ****   /* Clear PDDS and LPDS bits */
 712:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg &= CR_DS_MASK;
 455              		.loc 1 712 0
 456 0004 23F44063 		bic	r3, r3, #3072
 457              	.LVL22:
 458 0008 23F00303 		bic	r3, r3, #3
 459              	.LVL23:
 713:./FWLIB/src/stm32f4xx_pwr.c ****   
 714:./FWLIB/src/stm32f4xx_pwr.c ****   /* Set LPDS, MRLVDS and LPLVDS bits according to PWR_Regulator value */
 715:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator;
 460              		.loc 1 715 0
 461 000c 1843     		orrs	r0, r0, r3
 462              	.LVL24:
 716:./FWLIB/src/stm32f4xx_pwr.c ****   
 717:./FWLIB/src/stm32f4xx_pwr.c ****   /* Store the new value */
 718:./FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 463              		.loc 1 718 0
 464 000e 1060     		str	r0, [r2]
 719:./FWLIB/src/stm32f4xx_pwr.c ****   
 720:./FWLIB/src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 721:./FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 465              		.loc 1 721 0
 466 0010 084A     		ldr	r2, .L52+4
 467 0012 1369     		ldr	r3, [r2, #16]
 468 0014 43F00403 		orr	r3, r3, #4
 469 0018 1361     		str	r3, [r2, #16]
 722:./FWLIB/src/stm32f4xx_pwr.c ****   
 723:./FWLIB/src/stm32f4xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 724:./FWLIB/src/stm32f4xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 470              		.loc 1 724 0
 471 001a 0129     		cmp	r1, #1
 472 001c 06D0     		beq	.L51
 473              	.LBB12:
 474              	.LBB13:
 475              		.file 2 "build/lnInclude/core_cmInstr.h"
   1:build/lnInclude/core_cmInstr.h **** /**************************************************************************//**
   2:build/lnInclude/core_cmInstr.h ****  * @file     core_cmInstr.h
   3:build/lnInclude/core_cmInstr.h ****  * @brief    CMSIS Cortex-M Core Instruction Access Header File
   4:build/lnInclude/core_cmInstr.h ****  * @version  V3.20
   5:build/lnInclude/core_cmInstr.h ****  * @date     05. March 2013
   6:build/lnInclude/core_cmInstr.h ****  *
   7:build/lnInclude/core_cmInstr.h ****  * @note
   8:build/lnInclude/core_cmInstr.h ****  *
   9:build/lnInclude/core_cmInstr.h ****  ******************************************************************************/
  10:build/lnInclude/core_cmInstr.h **** /* Copyright (c) 2009 - 2013 ARM LIMITED
  11:build/lnInclude/core_cmInstr.h **** 
  12:build/lnInclude/core_cmInstr.h ****    All rights reserved.
  13:build/lnInclude/core_cmInstr.h ****    Redistribution and use in source and binary forms, with or without
  14:build/lnInclude/core_cmInstr.h ****    modification, are permitted provided that the following conditions are met:
  15:build/lnInclude/core_cmInstr.h ****    - Redistributions of source code must retain the above copyright
  16:build/lnInclude/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer.
  17:build/lnInclude/core_cmInstr.h ****    - Redistributions in binary form must reproduce the above copyright
  18:build/lnInclude/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer in the
  19:build/lnInclude/core_cmInstr.h ****      documentation and/or other materials provided with the distribution.
  20:build/lnInclude/core_cmInstr.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:build/lnInclude/core_cmInstr.h ****      to endorse or promote products derived from this software without
  22:build/lnInclude/core_cmInstr.h ****      specific prior written permission.
ARM GAS  /tmp/cca6hA9x.s 			page 22


  23:build/lnInclude/core_cmInstr.h ****    *
  24:build/lnInclude/core_cmInstr.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:build/lnInclude/core_cmInstr.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:build/lnInclude/core_cmInstr.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:build/lnInclude/core_cmInstr.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:build/lnInclude/core_cmInstr.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:build/lnInclude/core_cmInstr.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:build/lnInclude/core_cmInstr.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:build/lnInclude/core_cmInstr.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:build/lnInclude/core_cmInstr.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:build/lnInclude/core_cmInstr.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:build/lnInclude/core_cmInstr.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:build/lnInclude/core_cmInstr.h ****    ---------------------------------------------------------------------------*/
  36:build/lnInclude/core_cmInstr.h **** 
  37:build/lnInclude/core_cmInstr.h **** 
  38:build/lnInclude/core_cmInstr.h **** #ifndef __CORE_CMINSTR_H
  39:build/lnInclude/core_cmInstr.h **** #define __CORE_CMINSTR_H
  40:build/lnInclude/core_cmInstr.h **** 
  41:build/lnInclude/core_cmInstr.h **** 
  42:build/lnInclude/core_cmInstr.h **** /* ##########################  Core Instruction Access  ######################### */
  43:build/lnInclude/core_cmInstr.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  44:build/lnInclude/core_cmInstr.h ****   Access to dedicated instructions
  45:build/lnInclude/core_cmInstr.h ****   @{
  46:build/lnInclude/core_cmInstr.h **** */
  47:build/lnInclude/core_cmInstr.h **** 
  48:build/lnInclude/core_cmInstr.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  49:build/lnInclude/core_cmInstr.h **** /* ARM armcc specific functions */
  50:build/lnInclude/core_cmInstr.h **** 
  51:build/lnInclude/core_cmInstr.h **** #if (__ARMCC_VERSION < 400677)
  52:build/lnInclude/core_cmInstr.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  53:build/lnInclude/core_cmInstr.h **** #endif
  54:build/lnInclude/core_cmInstr.h **** 
  55:build/lnInclude/core_cmInstr.h **** 
  56:build/lnInclude/core_cmInstr.h **** /** \brief  No Operation
  57:build/lnInclude/core_cmInstr.h **** 
  58:build/lnInclude/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
  59:build/lnInclude/core_cmInstr.h ****  */
  60:build/lnInclude/core_cmInstr.h **** #define __NOP                             __nop
  61:build/lnInclude/core_cmInstr.h **** 
  62:build/lnInclude/core_cmInstr.h **** 
  63:build/lnInclude/core_cmInstr.h **** /** \brief  Wait For Interrupt
  64:build/lnInclude/core_cmInstr.h **** 
  65:build/lnInclude/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
  66:build/lnInclude/core_cmInstr.h ****     until one of a number of events occurs.
  67:build/lnInclude/core_cmInstr.h ****  */
  68:build/lnInclude/core_cmInstr.h **** #define __WFI                             __wfi
  69:build/lnInclude/core_cmInstr.h **** 
  70:build/lnInclude/core_cmInstr.h **** 
  71:build/lnInclude/core_cmInstr.h **** /** \brief  Wait For Event
  72:build/lnInclude/core_cmInstr.h **** 
  73:build/lnInclude/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
  74:build/lnInclude/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
  75:build/lnInclude/core_cmInstr.h ****  */
  76:build/lnInclude/core_cmInstr.h **** #define __WFE                             __wfe
  77:build/lnInclude/core_cmInstr.h **** 
  78:build/lnInclude/core_cmInstr.h **** 
  79:build/lnInclude/core_cmInstr.h **** /** \brief  Send Event
ARM GAS  /tmp/cca6hA9x.s 			page 23


  80:build/lnInclude/core_cmInstr.h **** 
  81:build/lnInclude/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
  82:build/lnInclude/core_cmInstr.h ****  */
  83:build/lnInclude/core_cmInstr.h **** #define __SEV                             __sev
  84:build/lnInclude/core_cmInstr.h **** 
  85:build/lnInclude/core_cmInstr.h **** 
  86:build/lnInclude/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
  87:build/lnInclude/core_cmInstr.h **** 
  88:build/lnInclude/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
  89:build/lnInclude/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
  90:build/lnInclude/core_cmInstr.h ****     memory, after the instruction has been completed.
  91:build/lnInclude/core_cmInstr.h ****  */
  92:build/lnInclude/core_cmInstr.h **** #define __ISB()                           __isb(0xF)
  93:build/lnInclude/core_cmInstr.h **** 
  94:build/lnInclude/core_cmInstr.h **** 
  95:build/lnInclude/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
  96:build/lnInclude/core_cmInstr.h **** 
  97:build/lnInclude/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
  98:build/lnInclude/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
  99:build/lnInclude/core_cmInstr.h ****  */
 100:build/lnInclude/core_cmInstr.h **** #define __DSB()                           __dsb(0xF)
 101:build/lnInclude/core_cmInstr.h **** 
 102:build/lnInclude/core_cmInstr.h **** 
 103:build/lnInclude/core_cmInstr.h **** /** \brief  Data Memory Barrier
 104:build/lnInclude/core_cmInstr.h **** 
 105:build/lnInclude/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
 106:build/lnInclude/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
 107:build/lnInclude/core_cmInstr.h ****  */
 108:build/lnInclude/core_cmInstr.h **** #define __DMB()                           __dmb(0xF)
 109:build/lnInclude/core_cmInstr.h **** 
 110:build/lnInclude/core_cmInstr.h **** 
 111:build/lnInclude/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
 112:build/lnInclude/core_cmInstr.h **** 
 113:build/lnInclude/core_cmInstr.h ****     This function reverses the byte order in integer value.
 114:build/lnInclude/core_cmInstr.h **** 
 115:build/lnInclude/core_cmInstr.h ****     \param [in]    value  Value to reverse
 116:build/lnInclude/core_cmInstr.h ****     \return               Reversed value
 117:build/lnInclude/core_cmInstr.h ****  */
 118:build/lnInclude/core_cmInstr.h **** #define __REV                             __rev
 119:build/lnInclude/core_cmInstr.h **** 
 120:build/lnInclude/core_cmInstr.h **** 
 121:build/lnInclude/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 122:build/lnInclude/core_cmInstr.h **** 
 123:build/lnInclude/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 124:build/lnInclude/core_cmInstr.h **** 
 125:build/lnInclude/core_cmInstr.h ****     \param [in]    value  Value to reverse
 126:build/lnInclude/core_cmInstr.h ****     \return               Reversed value
 127:build/lnInclude/core_cmInstr.h ****  */
 128:build/lnInclude/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 129:build/lnInclude/core_cmInstr.h **** __attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
 130:build/lnInclude/core_cmInstr.h **** {
 131:build/lnInclude/core_cmInstr.h ****   rev16 r0, r0
 132:build/lnInclude/core_cmInstr.h ****   bx lr
 133:build/lnInclude/core_cmInstr.h **** }
 134:build/lnInclude/core_cmInstr.h **** #endif
 135:build/lnInclude/core_cmInstr.h **** 
 136:build/lnInclude/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
ARM GAS  /tmp/cca6hA9x.s 			page 24


 137:build/lnInclude/core_cmInstr.h **** 
 138:build/lnInclude/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 139:build/lnInclude/core_cmInstr.h **** 
 140:build/lnInclude/core_cmInstr.h ****     \param [in]    value  Value to reverse
 141:build/lnInclude/core_cmInstr.h ****     \return               Reversed value
 142:build/lnInclude/core_cmInstr.h ****  */
 143:build/lnInclude/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 144:build/lnInclude/core_cmInstr.h **** __attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
 145:build/lnInclude/core_cmInstr.h **** {
 146:build/lnInclude/core_cmInstr.h ****   revsh r0, r0
 147:build/lnInclude/core_cmInstr.h ****   bx lr
 148:build/lnInclude/core_cmInstr.h **** }
 149:build/lnInclude/core_cmInstr.h **** #endif
 150:build/lnInclude/core_cmInstr.h **** 
 151:build/lnInclude/core_cmInstr.h **** 
 152:build/lnInclude/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 153:build/lnInclude/core_cmInstr.h **** 
 154:build/lnInclude/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
 155:build/lnInclude/core_cmInstr.h **** 
 156:build/lnInclude/core_cmInstr.h ****     \param [in]    value  Value to rotate
 157:build/lnInclude/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 158:build/lnInclude/core_cmInstr.h ****     \return               Rotated value
 159:build/lnInclude/core_cmInstr.h ****  */
 160:build/lnInclude/core_cmInstr.h **** #define __ROR                             __ror
 161:build/lnInclude/core_cmInstr.h **** 
 162:build/lnInclude/core_cmInstr.h **** 
 163:build/lnInclude/core_cmInstr.h **** /** \brief  Breakpoint
 164:build/lnInclude/core_cmInstr.h **** 
 165:build/lnInclude/core_cmInstr.h ****     This function causes the processor to enter Debug state.
 166:build/lnInclude/core_cmInstr.h ****     Debug tools can use this to investigate system state when the instruction at a particular addre
 167:build/lnInclude/core_cmInstr.h **** 
 168:build/lnInclude/core_cmInstr.h ****     \param [in]    value  is ignored by the processor.
 169:build/lnInclude/core_cmInstr.h ****                    If required, a debugger can use it to store additional information about the bre
 170:build/lnInclude/core_cmInstr.h ****  */
 171:build/lnInclude/core_cmInstr.h **** #define __BKPT(value)                       __breakpoint(value)
 172:build/lnInclude/core_cmInstr.h **** 
 173:build/lnInclude/core_cmInstr.h **** 
 174:build/lnInclude/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 175:build/lnInclude/core_cmInstr.h **** 
 176:build/lnInclude/core_cmInstr.h **** /** \brief  Reverse bit order of value
 177:build/lnInclude/core_cmInstr.h **** 
 178:build/lnInclude/core_cmInstr.h ****     This function reverses the bit order of the given value.
 179:build/lnInclude/core_cmInstr.h **** 
 180:build/lnInclude/core_cmInstr.h ****     \param [in]    value  Value to reverse
 181:build/lnInclude/core_cmInstr.h ****     \return               Reversed value
 182:build/lnInclude/core_cmInstr.h ****  */
 183:build/lnInclude/core_cmInstr.h **** #define __RBIT                            __rbit
 184:build/lnInclude/core_cmInstr.h **** 
 185:build/lnInclude/core_cmInstr.h **** 
 186:build/lnInclude/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 187:build/lnInclude/core_cmInstr.h **** 
 188:build/lnInclude/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 189:build/lnInclude/core_cmInstr.h **** 
 190:build/lnInclude/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 191:build/lnInclude/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 192:build/lnInclude/core_cmInstr.h ****  */
 193:build/lnInclude/core_cmInstr.h **** #define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
ARM GAS  /tmp/cca6hA9x.s 			page 25


 194:build/lnInclude/core_cmInstr.h **** 
 195:build/lnInclude/core_cmInstr.h **** 
 196:build/lnInclude/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 197:build/lnInclude/core_cmInstr.h **** 
 198:build/lnInclude/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 199:build/lnInclude/core_cmInstr.h **** 
 200:build/lnInclude/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 201:build/lnInclude/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 202:build/lnInclude/core_cmInstr.h ****  */
 203:build/lnInclude/core_cmInstr.h **** #define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
 204:build/lnInclude/core_cmInstr.h **** 
 205:build/lnInclude/core_cmInstr.h **** 
 206:build/lnInclude/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 207:build/lnInclude/core_cmInstr.h **** 
 208:build/lnInclude/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
 209:build/lnInclude/core_cmInstr.h **** 
 210:build/lnInclude/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 211:build/lnInclude/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 212:build/lnInclude/core_cmInstr.h ****  */
 213:build/lnInclude/core_cmInstr.h **** #define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
 214:build/lnInclude/core_cmInstr.h **** 
 215:build/lnInclude/core_cmInstr.h **** 
 216:build/lnInclude/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 217:build/lnInclude/core_cmInstr.h **** 
 218:build/lnInclude/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 219:build/lnInclude/core_cmInstr.h **** 
 220:build/lnInclude/core_cmInstr.h ****     \param [in]  value  Value to store
 221:build/lnInclude/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 222:build/lnInclude/core_cmInstr.h ****     \return          0  Function succeeded
 223:build/lnInclude/core_cmInstr.h ****     \return          1  Function failed
 224:build/lnInclude/core_cmInstr.h ****  */
 225:build/lnInclude/core_cmInstr.h **** #define __STREXB(value, ptr)              __strex(value, ptr)
 226:build/lnInclude/core_cmInstr.h **** 
 227:build/lnInclude/core_cmInstr.h **** 
 228:build/lnInclude/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 229:build/lnInclude/core_cmInstr.h **** 
 230:build/lnInclude/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 231:build/lnInclude/core_cmInstr.h **** 
 232:build/lnInclude/core_cmInstr.h ****     \param [in]  value  Value to store
 233:build/lnInclude/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 234:build/lnInclude/core_cmInstr.h ****     \return          0  Function succeeded
 235:build/lnInclude/core_cmInstr.h ****     \return          1  Function failed
 236:build/lnInclude/core_cmInstr.h ****  */
 237:build/lnInclude/core_cmInstr.h **** #define __STREXH(value, ptr)              __strex(value, ptr)
 238:build/lnInclude/core_cmInstr.h **** 
 239:build/lnInclude/core_cmInstr.h **** 
 240:build/lnInclude/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 241:build/lnInclude/core_cmInstr.h **** 
 242:build/lnInclude/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 243:build/lnInclude/core_cmInstr.h **** 
 244:build/lnInclude/core_cmInstr.h ****     \param [in]  value  Value to store
 245:build/lnInclude/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 246:build/lnInclude/core_cmInstr.h ****     \return          0  Function succeeded
 247:build/lnInclude/core_cmInstr.h ****     \return          1  Function failed
 248:build/lnInclude/core_cmInstr.h ****  */
 249:build/lnInclude/core_cmInstr.h **** #define __STREXW(value, ptr)              __strex(value, ptr)
 250:build/lnInclude/core_cmInstr.h **** 
ARM GAS  /tmp/cca6hA9x.s 			page 26


 251:build/lnInclude/core_cmInstr.h **** 
 252:build/lnInclude/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 253:build/lnInclude/core_cmInstr.h **** 
 254:build/lnInclude/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 255:build/lnInclude/core_cmInstr.h **** 
 256:build/lnInclude/core_cmInstr.h ****  */
 257:build/lnInclude/core_cmInstr.h **** #define __CLREX                           __clrex
 258:build/lnInclude/core_cmInstr.h **** 
 259:build/lnInclude/core_cmInstr.h **** 
 260:build/lnInclude/core_cmInstr.h **** /** \brief  Signed Saturate
 261:build/lnInclude/core_cmInstr.h **** 
 262:build/lnInclude/core_cmInstr.h ****     This function saturates a signed value.
 263:build/lnInclude/core_cmInstr.h **** 
 264:build/lnInclude/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 265:build/lnInclude/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 266:build/lnInclude/core_cmInstr.h ****     \return             Saturated value
 267:build/lnInclude/core_cmInstr.h ****  */
 268:build/lnInclude/core_cmInstr.h **** #define __SSAT                            __ssat
 269:build/lnInclude/core_cmInstr.h **** 
 270:build/lnInclude/core_cmInstr.h **** 
 271:build/lnInclude/core_cmInstr.h **** /** \brief  Unsigned Saturate
 272:build/lnInclude/core_cmInstr.h **** 
 273:build/lnInclude/core_cmInstr.h ****     This function saturates an unsigned value.
 274:build/lnInclude/core_cmInstr.h **** 
 275:build/lnInclude/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 276:build/lnInclude/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 277:build/lnInclude/core_cmInstr.h ****     \return             Saturated value
 278:build/lnInclude/core_cmInstr.h ****  */
 279:build/lnInclude/core_cmInstr.h **** #define __USAT                            __usat
 280:build/lnInclude/core_cmInstr.h **** 
 281:build/lnInclude/core_cmInstr.h **** 
 282:build/lnInclude/core_cmInstr.h **** /** \brief  Count leading zeros
 283:build/lnInclude/core_cmInstr.h **** 
 284:build/lnInclude/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 285:build/lnInclude/core_cmInstr.h **** 
 286:build/lnInclude/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 287:build/lnInclude/core_cmInstr.h ****     \return             number of leading zeros in value
 288:build/lnInclude/core_cmInstr.h ****  */
 289:build/lnInclude/core_cmInstr.h **** #define __CLZ                             __clz
 290:build/lnInclude/core_cmInstr.h **** 
 291:build/lnInclude/core_cmInstr.h **** #endif /* (__CORTEX_M >= 0x03) */
 292:build/lnInclude/core_cmInstr.h **** 
 293:build/lnInclude/core_cmInstr.h **** 
 294:build/lnInclude/core_cmInstr.h **** 
 295:build/lnInclude/core_cmInstr.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 296:build/lnInclude/core_cmInstr.h **** /* IAR iccarm specific functions */
 297:build/lnInclude/core_cmInstr.h **** 
 298:build/lnInclude/core_cmInstr.h **** #include <cmsis_iar.h>
 299:build/lnInclude/core_cmInstr.h **** 
 300:build/lnInclude/core_cmInstr.h **** 
 301:build/lnInclude/core_cmInstr.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 302:build/lnInclude/core_cmInstr.h **** /* TI CCS specific functions */
 303:build/lnInclude/core_cmInstr.h **** 
 304:build/lnInclude/core_cmInstr.h **** #include <cmsis_ccs.h>
 305:build/lnInclude/core_cmInstr.h **** 
 306:build/lnInclude/core_cmInstr.h **** 
 307:build/lnInclude/core_cmInstr.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
ARM GAS  /tmp/cca6hA9x.s 			page 27


 308:build/lnInclude/core_cmInstr.h **** /* GNU gcc specific functions */
 309:build/lnInclude/core_cmInstr.h **** 
 310:build/lnInclude/core_cmInstr.h **** /* Define macros for porting to both thumb1 and thumb2.
 311:build/lnInclude/core_cmInstr.h ****  * For thumb1, use low register (r0-r7), specified by constrant "l"
 312:build/lnInclude/core_cmInstr.h ****  * Otherwise, use general registers, specified by constrant "r" */
 313:build/lnInclude/core_cmInstr.h **** #if defined (__thumb__) && !defined (__thumb2__)
 314:build/lnInclude/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 315:build/lnInclude/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 316:build/lnInclude/core_cmInstr.h **** #else
 317:build/lnInclude/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 318:build/lnInclude/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 319:build/lnInclude/core_cmInstr.h **** #endif
 320:build/lnInclude/core_cmInstr.h **** 
 321:build/lnInclude/core_cmInstr.h **** /** \brief  No Operation
 322:build/lnInclude/core_cmInstr.h **** 
 323:build/lnInclude/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 324:build/lnInclude/core_cmInstr.h ****  */
 325:build/lnInclude/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
 326:build/lnInclude/core_cmInstr.h **** {
 327:build/lnInclude/core_cmInstr.h ****   __ASM volatile ("nop");
 328:build/lnInclude/core_cmInstr.h **** }
 329:build/lnInclude/core_cmInstr.h **** 
 330:build/lnInclude/core_cmInstr.h **** 
 331:build/lnInclude/core_cmInstr.h **** /** \brief  Wait For Interrupt
 332:build/lnInclude/core_cmInstr.h **** 
 333:build/lnInclude/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
 334:build/lnInclude/core_cmInstr.h ****     until one of a number of events occurs.
 335:build/lnInclude/core_cmInstr.h ****  */
 336:build/lnInclude/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
 337:build/lnInclude/core_cmInstr.h **** {
 338:build/lnInclude/core_cmInstr.h ****   __ASM volatile ("wfi");
 339:build/lnInclude/core_cmInstr.h **** }
 340:build/lnInclude/core_cmInstr.h **** 
 341:build/lnInclude/core_cmInstr.h **** 
 342:build/lnInclude/core_cmInstr.h **** /** \brief  Wait For Event
 343:build/lnInclude/core_cmInstr.h **** 
 344:build/lnInclude/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
 345:build/lnInclude/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
 346:build/lnInclude/core_cmInstr.h ****  */
 347:build/lnInclude/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
 348:build/lnInclude/core_cmInstr.h **** {
 349:build/lnInclude/core_cmInstr.h ****   __ASM volatile ("wfe");
 476              		.loc 2 349 0
 477              		.syntax unified
 478              	@ 349 "build/lnInclude/core_cmInstr.h" 1
 479 001e 20BF     		wfe
 480              	@ 0 "" 2
 481              		.thumb
 482              		.syntax unified
 483              	.L50:
 484              	.LBE13:
 485              	.LBE12:
 725:./FWLIB/src/stm32f4xx_pwr.c ****   {   
 726:./FWLIB/src/stm32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 727:./FWLIB/src/stm32f4xx_pwr.c ****     __WFI();
 728:./FWLIB/src/stm32f4xx_pwr.c ****   }
 729:./FWLIB/src/stm32f4xx_pwr.c ****   else
ARM GAS  /tmp/cca6hA9x.s 			page 28


 730:./FWLIB/src/stm32f4xx_pwr.c ****   {
 731:./FWLIB/src/stm32f4xx_pwr.c ****     /* Request Wait For Event */
 732:./FWLIB/src/stm32f4xx_pwr.c ****     __WFE();
 733:./FWLIB/src/stm32f4xx_pwr.c ****   }
 734:./FWLIB/src/stm32f4xx_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 735:./FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 486              		.loc 1 735 0
 487 0020 044A     		ldr	r2, .L52+4
 488 0022 1369     		ldr	r3, [r2, #16]
 489 0024 23F00403 		bic	r3, r3, #4
 490 0028 1361     		str	r3, [r2, #16]
 736:./FWLIB/src/stm32f4xx_pwr.c **** }
 491              		.loc 1 736 0
 492 002a 7047     		bx	lr
 493              	.L51:
 494              	.LBB14:
 495              	.LBB15:
 338:build/lnInclude/core_cmInstr.h **** }
 496              		.loc 2 338 0
 497              		.syntax unified
 498              	@ 338 "build/lnInclude/core_cmInstr.h" 1
 499 002c 30BF     		wfi
 500              	@ 0 "" 2
 501              		.thumb
 502              		.syntax unified
 503 002e F7E7     		b	.L50
 504              	.L53:
 505              		.align	2
 506              	.L52:
 507 0030 00700040 		.word	1073770496
 508 0034 00ED00E0 		.word	-536810240
 509              	.LBE15:
 510              	.LBE14:
 511              		.cfi_endproc
 512              	.LFE125:
 514              		.section	.text.PWR_EnterUnderDriveSTOPMode,"ax",%progbits
 515              		.align	1
 516              		.global	PWR_EnterUnderDriveSTOPMode
 517              		.syntax unified
 518              		.thumb
 519              		.thumb_func
 520              		.fpu fpv4-sp-d16
 522              	PWR_EnterUnderDriveSTOPMode:
 523              	.LFB126:
 737:./FWLIB/src/stm32f4xx_pwr.c **** 
 738:./FWLIB/src/stm32f4xx_pwr.c **** /**
 739:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enters in Under-Drive STOP mode.
 740:./FWLIB/src/stm32f4xx_pwr.c ****   *  
 741:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   This mode is only available for STM32F42xxx/STM3243xxx devices. 
 742:./FWLIB/src/stm32f4xx_pwr.c ****   * 
 743:./FWLIB/src/stm32f4xx_pwr.c ****   * @note    This mode can be selected only when the Under-Drive is already active 
 744:./FWLIB/src/stm32f4xx_pwr.c ****   *         
 745:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 746:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
 747:./FWLIB/src/stm32f4xx_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 748:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   When the voltage regulator operates in low power mode, an additional 
 749:./FWLIB/src/stm32f4xx_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
ARM GAS  /tmp/cca6hA9x.s 			page 29


 750:./FWLIB/src/stm32f4xx_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption 
 751:./FWLIB/src/stm32f4xx_pwr.c ****   *         is higher although the startup time is reduced.
 752:./FWLIB/src/stm32f4xx_pwr.c ****   *     
 753:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 754:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 755:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_MainRegulator_UnderDrive_ON:  Main Regulator in under-drive mode 
 756:./FWLIB/src/stm32f4xx_pwr.c ****   *                 and Flash memory in power-down when the device is in Stop under-drive mode
 757:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_LowPowerRegulator_UnderDrive_ON:  Low Power Regulator in under-drive mode 
 758:./FWLIB/src/stm32f4xx_pwr.c ****   *                and Flash memory in power-down when the device is in Stop under-drive mode
 759:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 760:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 761:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 762:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 763:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 764:./FWLIB/src/stm32f4xx_pwr.c ****   */
 765:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
 766:./FWLIB/src/stm32f4xx_pwr.c **** {
 524              		.loc 1 766 0
 525              		.cfi_startproc
 526              		@ args = 0, pretend = 0, frame = 0
 527              		@ frame_needed = 0, uses_anonymous_args = 0
 528              		@ link register save eliminated.
 529              	.LVL25:
 767:./FWLIB/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 768:./FWLIB/src/stm32f4xx_pwr.c ****   
 769:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 770:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR_UNDERDRIVE(PWR_Regulator));
 771:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 772:./FWLIB/src/stm32f4xx_pwr.c ****   
 773:./FWLIB/src/stm32f4xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 774:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 530              		.loc 1 774 0
 531 0000 0B4A     		ldr	r2, .L58
 532 0002 1368     		ldr	r3, [r2]
 533              	.LVL26:
 775:./FWLIB/src/stm32f4xx_pwr.c ****   /* Clear PDDS and LPDS bits */
 776:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg &= CR_DS_MASK;
 534              		.loc 1 776 0
 535 0004 23F44063 		bic	r3, r3, #3072
 536              	.LVL27:
 537 0008 23F00303 		bic	r3, r3, #3
 538              	.LVL28:
 777:./FWLIB/src/stm32f4xx_pwr.c ****   
 778:./FWLIB/src/stm32f4xx_pwr.c ****   /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
 779:./FWLIB/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator;
 539              		.loc 1 779 0
 540 000c 1843     		orrs	r0, r0, r3
 541              	.LVL29:
 780:./FWLIB/src/stm32f4xx_pwr.c ****   
 781:./FWLIB/src/stm32f4xx_pwr.c ****   /* Store the new value */
 782:./FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 542              		.loc 1 782 0
 543 000e 1060     		str	r0, [r2]
 783:./FWLIB/src/stm32f4xx_pwr.c ****   
 784:./FWLIB/src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 785:./FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 544              		.loc 1 785 0
ARM GAS  /tmp/cca6hA9x.s 			page 30


 545 0010 084A     		ldr	r2, .L58+4
 546 0012 1369     		ldr	r3, [r2, #16]
 547 0014 43F00403 		orr	r3, r3, #4
 548 0018 1361     		str	r3, [r2, #16]
 786:./FWLIB/src/stm32f4xx_pwr.c ****   
 787:./FWLIB/src/stm32f4xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 788:./FWLIB/src/stm32f4xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 549              		.loc 1 788 0
 550 001a 0129     		cmp	r1, #1
 551 001c 06D0     		beq	.L57
 552              	.LBB16:
 553              	.LBB17:
 554              		.loc 2 349 0
 555              		.syntax unified
 556              	@ 349 "build/lnInclude/core_cmInstr.h" 1
 557 001e 20BF     		wfe
 558              	@ 0 "" 2
 559              		.thumb
 560              		.syntax unified
 561              	.L56:
 562              	.LBE17:
 563              	.LBE16:
 789:./FWLIB/src/stm32f4xx_pwr.c ****   {   
 790:./FWLIB/src/stm32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 791:./FWLIB/src/stm32f4xx_pwr.c ****     __WFI();
 792:./FWLIB/src/stm32f4xx_pwr.c ****   }
 793:./FWLIB/src/stm32f4xx_pwr.c ****   else
 794:./FWLIB/src/stm32f4xx_pwr.c ****   {
 795:./FWLIB/src/stm32f4xx_pwr.c ****     /* Request Wait For Event */
 796:./FWLIB/src/stm32f4xx_pwr.c ****     __WFE();
 797:./FWLIB/src/stm32f4xx_pwr.c ****   }
 798:./FWLIB/src/stm32f4xx_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 799:./FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 564              		.loc 1 799 0
 565 0020 044A     		ldr	r2, .L58+4
 566 0022 1369     		ldr	r3, [r2, #16]
 567 0024 23F00403 		bic	r3, r3, #4
 568 0028 1361     		str	r3, [r2, #16]
 800:./FWLIB/src/stm32f4xx_pwr.c **** }
 569              		.loc 1 800 0
 570 002a 7047     		bx	lr
 571              	.L57:
 572              	.LBB18:
 573              	.LBB19:
 338:build/lnInclude/core_cmInstr.h **** }
 574              		.loc 2 338 0
 575              		.syntax unified
 576              	@ 338 "build/lnInclude/core_cmInstr.h" 1
 577 002c 30BF     		wfi
 578              	@ 0 "" 2
 579              		.thumb
 580              		.syntax unified
 581 002e F7E7     		b	.L56
 582              	.L59:
 583              		.align	2
 584              	.L58:
 585 0030 00700040 		.word	1073770496
ARM GAS  /tmp/cca6hA9x.s 			page 31


 586 0034 00ED00E0 		.word	-536810240
 587              	.LBE19:
 588              	.LBE18:
 589              		.cfi_endproc
 590              	.LFE126:
 592              		.section	.text.PWR_EnterSTANDBYMode,"ax",%progbits
 593              		.align	1
 594              		.global	PWR_EnterSTANDBYMode
 595              		.syntax unified
 596              		.thumb
 597              		.thumb_func
 598              		.fpu fpv4-sp-d16
 600              	PWR_EnterSTANDBYMode:
 601              	.LFB127:
 801:./FWLIB/src/stm32f4xx_pwr.c **** 
 802:./FWLIB/src/stm32f4xx_pwr.c **** /**
 803:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enters STANDBY mode.
 804:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   In Standby mode, all I/O pins are high impedance except for:
 805:./FWLIB/src/stm32f4xx_pwr.c ****   *          - Reset pad (still available) 
 806:./FWLIB/src/stm32f4xx_pwr.c ****   *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC 
 807:./FWLIB/src/stm32f4xx_pwr.c ****   *            Alarm out, or RTC clock calibration out.
 808:./FWLIB/src/stm32f4xx_pwr.c ****   *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
 809:./FWLIB/src/stm32f4xx_pwr.c ****   *          - WKUP pin 1 (PA0) if enabled.
 810:./FWLIB/src/stm32f4xx_pwr.c ****   * @note   The Wakeup flag (WUF) need to be cleared at application level before to call this funct
 811:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  None
 812:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 813:./FWLIB/src/stm32f4xx_pwr.c ****   */
 814:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_EnterSTANDBYMode(void)
 815:./FWLIB/src/stm32f4xx_pwr.c **** {
 602              		.loc 1 815 0
 603              		.cfi_startproc
 604              		@ args = 0, pretend = 0, frame = 0
 605              		@ frame_needed = 0, uses_anonymous_args = 0
 606              		@ link register save eliminated.
 816:./FWLIB/src/stm32f4xx_pwr.c ****   /* Select STANDBY mode */
 817:./FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR |= PWR_CR_PDDS;
 607              		.loc 1 817 0
 608 0000 054A     		ldr	r2, .L61
 609 0002 1368     		ldr	r3, [r2]
 610 0004 43F00203 		orr	r3, r3, #2
 611 0008 1360     		str	r3, [r2]
 818:./FWLIB/src/stm32f4xx_pwr.c ****   
 819:./FWLIB/src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 820:./FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 612              		.loc 1 820 0
 613 000a 044A     		ldr	r2, .L61+4
 614 000c 1369     		ldr	r3, [r2, #16]
 615 000e 43F00403 		orr	r3, r3, #4
 616 0012 1361     		str	r3, [r2, #16]
 617              	.LBB20:
 618              	.LBB21:
 338:build/lnInclude/core_cmInstr.h **** }
 619              		.loc 2 338 0
 620              		.syntax unified
 621              	@ 338 "build/lnInclude/core_cmInstr.h" 1
 622 0014 30BF     		wfi
 623              	@ 0 "" 2
ARM GAS  /tmp/cca6hA9x.s 			page 32


 624              		.thumb
 625              		.syntax unified
 626              	.LBE21:
 627              	.LBE20:
 821:./FWLIB/src/stm32f4xx_pwr.c ****   
 822:./FWLIB/src/stm32f4xx_pwr.c ****   /* This option is used to ensure that store operations are completed */
 823:./FWLIB/src/stm32f4xx_pwr.c **** #if defined ( __CC_ARM   )
 824:./FWLIB/src/stm32f4xx_pwr.c ****   __force_stores();
 825:./FWLIB/src/stm32f4xx_pwr.c **** #endif
 826:./FWLIB/src/stm32f4xx_pwr.c ****   /* Request Wait For Interrupt */
 827:./FWLIB/src/stm32f4xx_pwr.c ****   __WFI();
 828:./FWLIB/src/stm32f4xx_pwr.c **** }
 628              		.loc 1 828 0
 629 0016 7047     		bx	lr
 630              	.L62:
 631              		.align	2
 632              	.L61:
 633 0018 00700040 		.word	1073770496
 634 001c 00ED00E0 		.word	-536810240
 635              		.cfi_endproc
 636              	.LFE127:
 638              		.section	.text.PWR_GetFlagStatus,"ax",%progbits
 639              		.align	1
 640              		.global	PWR_GetFlagStatus
 641              		.syntax unified
 642              		.thumb
 643              		.thumb_func
 644              		.fpu fpv4-sp-d16
 646              	PWR_GetFlagStatus:
 647              	.LFB128:
 829:./FWLIB/src/stm32f4xx_pwr.c **** 
 830:./FWLIB/src/stm32f4xx_pwr.c **** /**
 831:./FWLIB/src/stm32f4xx_pwr.c ****   * @}
 832:./FWLIB/src/stm32f4xx_pwr.c ****   */
 833:./FWLIB/src/stm32f4xx_pwr.c **** 
 834:./FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group7 Flags management functions
 835:./FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   Flags management functions 
 836:./FWLIB/src/stm32f4xx_pwr.c ****  *
 837:./FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 838:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 839:./FWLIB/src/stm32f4xx_pwr.c ****                     ##### Flags management functions #####
 840:./FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 841:./FWLIB/src/stm32f4xx_pwr.c **** 
 842:./FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 843:./FWLIB/src/stm32f4xx_pwr.c ****   * @{
 844:./FWLIB/src/stm32f4xx_pwr.c ****   */
 845:./FWLIB/src/stm32f4xx_pwr.c **** 
 846:./FWLIB/src/stm32f4xx_pwr.c **** /**
 847:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Checks whether the specified PWR flag is set or not.
 848:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to check.
 849:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 850:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
 851:./FWLIB/src/stm32f4xx_pwr.c ****   *                  was received from the WKUP pin or from the RTC alarm (Alarm A 
 852:./FWLIB/src/stm32f4xx_pwr.c ****   *                  or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
 853:./FWLIB/src/stm32f4xx_pwr.c ****   *                  An additional wakeup event is detected if the WKUP pin is enabled 
 854:./FWLIB/src/stm32f4xx_pwr.c ****   *                  (by setting the EWUP bit) when the WKUP pin level is already high.  
 855:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
ARM GAS  /tmp/cca6hA9x.s 			page 33


 856:./FWLIB/src/stm32f4xx_pwr.c ****   *                  resumed from StandBy mode.    
 857:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
 858:./FWLIB/src/stm32f4xx_pwr.c ****   *                  by the PWR_PVDCmd() function. The PVD is stopped by Standby mode 
 859:./FWLIB/src/stm32f4xx_pwr.c ****   *                  For this reason, this bit is equal to 0 after Standby or reset
 860:./FWLIB/src/stm32f4xx_pwr.c ****   *                  until the PVDE bit is set.
 861:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
 862:./FWLIB/src/stm32f4xx_pwr.c ****   *                  when the device wakes up from Standby mode or by a system reset 
 863:./FWLIB/src/stm32f4xx_pwr.c ****   *                  or power reset.  
 864:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
 865:./FWLIB/src/stm32f4xx_pwr.c ****   *                 scaling output selection is ready.
 866:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_ODRDY: This flag indicates that the Over-drive mode
 867:./FWLIB/src/stm32f4xx_pwr.c ****   *                 is ready (STM32F42xxx/43xxx devices) 
 868:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_ODSWRDY: This flag indicates that the Over-drive mode
 869:./FWLIB/src/stm32f4xx_pwr.c ****   *                 switcching is ready (STM32F42xxx/43xxx devices) 
 870:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_UDRDY: This flag indicates that the Under-drive mode
 871:./FWLIB/src/stm32f4xx_pwr.c ****   *                 is enabled in Stop mode (STM32F42xxx/43xxx devices)
 872:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval The new state of PWR_FLAG (SET or RESET).
 873:./FWLIB/src/stm32f4xx_pwr.c ****   */
 874:./FWLIB/src/stm32f4xx_pwr.c **** FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
 875:./FWLIB/src/stm32f4xx_pwr.c **** {
 648              		.loc 1 875 0
 649              		.cfi_startproc
 650              		@ args = 0, pretend = 0, frame = 0
 651              		@ frame_needed = 0, uses_anonymous_args = 0
 652              		@ link register save eliminated.
 653              	.LVL30:
 876:./FWLIB/src/stm32f4xx_pwr.c ****   FlagStatus bitstatus = RESET;
 877:./FWLIB/src/stm32f4xx_pwr.c ****   
 878:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 879:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
 880:./FWLIB/src/stm32f4xx_pwr.c ****   
 881:./FWLIB/src/stm32f4xx_pwr.c ****   if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 654              		.loc 1 881 0
 655 0000 034B     		ldr	r3, .L67
 656 0002 5B68     		ldr	r3, [r3, #4]
 657 0004 0342     		tst	r3, r0
 658 0006 01D1     		bne	.L66
 882:./FWLIB/src/stm32f4xx_pwr.c ****   {
 883:./FWLIB/src/stm32f4xx_pwr.c ****     bitstatus = SET;
 884:./FWLIB/src/stm32f4xx_pwr.c ****   }
 885:./FWLIB/src/stm32f4xx_pwr.c ****   else
 886:./FWLIB/src/stm32f4xx_pwr.c ****   {
 887:./FWLIB/src/stm32f4xx_pwr.c ****     bitstatus = RESET;
 659              		.loc 1 887 0
 660 0008 0020     		movs	r0, #0
 661              	.LVL31:
 888:./FWLIB/src/stm32f4xx_pwr.c ****   }
 889:./FWLIB/src/stm32f4xx_pwr.c ****   /* Return the flag status */
 890:./FWLIB/src/stm32f4xx_pwr.c ****   return bitstatus;
 891:./FWLIB/src/stm32f4xx_pwr.c **** }
 662              		.loc 1 891 0
 663 000a 7047     		bx	lr
 664              	.LVL32:
 665              	.L66:
 883:./FWLIB/src/stm32f4xx_pwr.c ****   }
 666              		.loc 1 883 0
 667 000c 0120     		movs	r0, #1
ARM GAS  /tmp/cca6hA9x.s 			page 34


 668              	.LVL33:
 669 000e 7047     		bx	lr
 670              	.L68:
 671              		.align	2
 672              	.L67:
 673 0010 00700040 		.word	1073770496
 674              		.cfi_endproc
 675              	.LFE128:
 677              		.section	.text.PWR_ClearFlag,"ax",%progbits
 678              		.align	1
 679              		.global	PWR_ClearFlag
 680              		.syntax unified
 681              		.thumb
 682              		.thumb_func
 683              		.fpu fpv4-sp-d16
 685              	PWR_ClearFlag:
 686              	.LFB129:
 892:./FWLIB/src/stm32f4xx_pwr.c **** 
 893:./FWLIB/src/stm32f4xx_pwr.c **** /**
 894:./FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Clears the PWR's pending flags.
 895:./FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to clear.
 896:./FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 897:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_WU: Wake Up flag
 898:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_SB: StandBy flag
 899:./FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_UDRDY: Under-drive ready flag (STM32F42xxx/43xxx devices)
 900:./FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 901:./FWLIB/src/stm32f4xx_pwr.c ****   */
 902:./FWLIB/src/stm32f4xx_pwr.c **** void PWR_ClearFlag(uint32_t PWR_FLAG)
 903:./FWLIB/src/stm32f4xx_pwr.c **** {
 687              		.loc 1 903 0
 688              		.cfi_startproc
 689              		@ args = 0, pretend = 0, frame = 0
 690              		@ frame_needed = 0, uses_anonymous_args = 0
 691              		@ link register save eliminated.
 692              	.LVL34:
 904:./FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 905:./FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
 906:./FWLIB/src/stm32f4xx_pwr.c ****   
 907:./FWLIB/src/stm32f4xx_pwr.c **** #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
 908:./FWLIB/src/stm32f4xx_pwr.c ****   if (PWR_FLAG != PWR_FLAG_UDRDY)
 909:./FWLIB/src/stm32f4xx_pwr.c ****   {
 910:./FWLIB/src/stm32f4xx_pwr.c ****     PWR->CR |=  PWR_FLAG << 2;
 911:./FWLIB/src/stm32f4xx_pwr.c ****   }
 912:./FWLIB/src/stm32f4xx_pwr.c ****   else
 913:./FWLIB/src/stm32f4xx_pwr.c ****   {
 914:./FWLIB/src/stm32f4xx_pwr.c ****     PWR->CSR |= PWR_FLAG_UDRDY;
 915:./FWLIB/src/stm32f4xx_pwr.c ****   }
 916:./FWLIB/src/stm32f4xx_pwr.c **** #endif /* STM32F427_437xx ||  STM32F429_439xx */
 917:./FWLIB/src/stm32f4xx_pwr.c **** 
 918:./FWLIB/src/stm32f4xx_pwr.c **** #if defined (STM32F40_41xxx) || defined (STM32F401xx) || defined (STM32F411xE) 
 919:./FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR |=  PWR_FLAG << 2;
 693              		.loc 1 919 0
 694 0000 024A     		ldr	r2, .L70
 695 0002 1368     		ldr	r3, [r2]
 696 0004 43EA8000 		orr	r0, r3, r0, lsl #2
 697              	.LVL35:
 698 0008 1060     		str	r0, [r2]
ARM GAS  /tmp/cca6hA9x.s 			page 35


 920:./FWLIB/src/stm32f4xx_pwr.c **** #endif /* STM32F40_41xxx  || STM32F401xx || STM32F411xE */
 921:./FWLIB/src/stm32f4xx_pwr.c **** }
 699              		.loc 1 921 0
 700 000a 7047     		bx	lr
 701              	.L71:
 702              		.align	2
 703              	.L70:
 704 000c 00700040 		.word	1073770496
 705              		.cfi_endproc
 706              	.LFE129:
 708              		.text
 709              	.Letext0:
 710              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 711              		.file 4 "/usr/arm-none-eabi/include/sys/_stdint.h"
 712              		.file 5 "build/lnInclude/core_cm4.h"
 713              		.file 6 "build/lnInclude/system_stm32f4xx.h"
 714              		.file 7 "build/lnInclude/stm32f4xx.h"
 715              		.file 8 "build/lnInclude/stm32f4xx_rcc.h"
ARM GAS  /tmp/cca6hA9x.s 			page 36


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f4xx_pwr.c
     /tmp/cca6hA9x.s:18     .text.PWR_DeInit:0000000000000000 $t
     /tmp/cca6hA9x.s:25     .text.PWR_DeInit:0000000000000000 PWR_DeInit
     /tmp/cca6hA9x.s:53     .text.PWR_BackupAccessCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:60     .text.PWR_BackupAccessCmd:0000000000000000 PWR_BackupAccessCmd
     /tmp/cca6hA9x.s:76     .text.PWR_BackupAccessCmd:0000000000000008 $d
     /tmp/cca6hA9x.s:81     .text.PWR_PVDLevelConfig:0000000000000000 $t
     /tmp/cca6hA9x.s:88     .text.PWR_PVDLevelConfig:0000000000000000 PWR_PVDLevelConfig
     /tmp/cca6hA9x.s:113    .text.PWR_PVDLevelConfig:0000000000000010 $d
     /tmp/cca6hA9x.s:118    .text.PWR_PVDCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:125    .text.PWR_PVDCmd:0000000000000000 PWR_PVDCmd
     /tmp/cca6hA9x.s:141    .text.PWR_PVDCmd:0000000000000008 $d
     /tmp/cca6hA9x.s:146    .text.PWR_WakeUpPinCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:153    .text.PWR_WakeUpPinCmd:0000000000000000 PWR_WakeUpPinCmd
     /tmp/cca6hA9x.s:169    .text.PWR_WakeUpPinCmd:0000000000000008 $d
     /tmp/cca6hA9x.s:174    .text.PWR_BackupRegulatorCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:181    .text.PWR_BackupRegulatorCmd:0000000000000000 PWR_BackupRegulatorCmd
     /tmp/cca6hA9x.s:197    .text.PWR_BackupRegulatorCmd:0000000000000008 $d
     /tmp/cca6hA9x.s:202    .text.PWR_MainRegulatorModeConfig:0000000000000000 $t
     /tmp/cca6hA9x.s:209    .text.PWR_MainRegulatorModeConfig:0000000000000000 PWR_MainRegulatorModeConfig
     /tmp/cca6hA9x.s:234    .text.PWR_MainRegulatorModeConfig:0000000000000010 $d
     /tmp/cca6hA9x.s:239    .text.PWR_OverDriveCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:246    .text.PWR_OverDriveCmd:0000000000000000 PWR_OverDriveCmd
     /tmp/cca6hA9x.s:262    .text.PWR_OverDriveCmd:0000000000000008 $d
     /tmp/cca6hA9x.s:267    .text.PWR_OverDriveSWCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:274    .text.PWR_OverDriveSWCmd:0000000000000000 PWR_OverDriveSWCmd
     /tmp/cca6hA9x.s:290    .text.PWR_OverDriveSWCmd:0000000000000008 $d
     /tmp/cca6hA9x.s:295    .text.PWR_UnderDriveCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:302    .text.PWR_UnderDriveCmd:0000000000000000 PWR_UnderDriveCmd
     /tmp/cca6hA9x.s:329    .text.PWR_UnderDriveCmd:000000000000001c $d
     /tmp/cca6hA9x.s:334    .text.PWR_MainRegulatorLowVoltageCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:341    .text.PWR_MainRegulatorLowVoltageCmd:0000000000000000 PWR_MainRegulatorLowVoltageCmd
     /tmp/cca6hA9x.s:366    .text.PWR_MainRegulatorLowVoltageCmd:0000000000000014 $d
     /tmp/cca6hA9x.s:371    .text.PWR_LowRegulatorLowVoltageCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:378    .text.PWR_LowRegulatorLowVoltageCmd:0000000000000000 PWR_LowRegulatorLowVoltageCmd
     /tmp/cca6hA9x.s:403    .text.PWR_LowRegulatorLowVoltageCmd:0000000000000014 $d
     /tmp/cca6hA9x.s:408    .text.PWR_FlashPowerDownCmd:0000000000000000 $t
     /tmp/cca6hA9x.s:415    .text.PWR_FlashPowerDownCmd:0000000000000000 PWR_FlashPowerDownCmd
     /tmp/cca6hA9x.s:431    .text.PWR_FlashPowerDownCmd:0000000000000008 $d
     /tmp/cca6hA9x.s:436    .text.PWR_EnterSTOPMode:0000000000000000 $t
     /tmp/cca6hA9x.s:443    .text.PWR_EnterSTOPMode:0000000000000000 PWR_EnterSTOPMode
     /tmp/cca6hA9x.s:507    .text.PWR_EnterSTOPMode:0000000000000030 $d
     /tmp/cca6hA9x.s:515    .text.PWR_EnterUnderDriveSTOPMode:0000000000000000 $t
     /tmp/cca6hA9x.s:522    .text.PWR_EnterUnderDriveSTOPMode:0000000000000000 PWR_EnterUnderDriveSTOPMode
     /tmp/cca6hA9x.s:585    .text.PWR_EnterUnderDriveSTOPMode:0000000000000030 $d
     /tmp/cca6hA9x.s:593    .text.PWR_EnterSTANDBYMode:0000000000000000 $t
     /tmp/cca6hA9x.s:600    .text.PWR_EnterSTANDBYMode:0000000000000000 PWR_EnterSTANDBYMode
     /tmp/cca6hA9x.s:633    .text.PWR_EnterSTANDBYMode:0000000000000018 $d
     /tmp/cca6hA9x.s:639    .text.PWR_GetFlagStatus:0000000000000000 $t
     /tmp/cca6hA9x.s:646    .text.PWR_GetFlagStatus:0000000000000000 PWR_GetFlagStatus
     /tmp/cca6hA9x.s:673    .text.PWR_GetFlagStatus:0000000000000010 $d
     /tmp/cca6hA9x.s:678    .text.PWR_ClearFlag:0000000000000000 $t
     /tmp/cca6hA9x.s:685    .text.PWR_ClearFlag:0000000000000000 PWR_ClearFlag
     /tmp/cca6hA9x.s:704    .text.PWR_ClearFlag:000000000000000c $d

UNDEFINED SYMBOLS
ARM GAS  /tmp/cca6hA9x.s 			page 37


RCC_APB1PeriphResetCmd
